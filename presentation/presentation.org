#+BEAMER_THEME: default
#+BEAMER_COLOR_THEME: default
#+TITLE: An strict backend for Agda
#+SUBTITLE: agda2mlf
#+AUTHOR: Frederik Hanghøj Iversen, Jan Mas Rovira
#+OPTIONS: H:2
#+DATE: \today

* Introduction
  # Describe design-considerations and challenges and limitations (backlog)
** Introduction
   We present our efforts to implement a backend for Agda targeting OCaml. We
   present some of the problems we ran into along the way as well as limitations
   of the current implementation. The motivation for the project was to explore
   if it was possible to gain a performance boost by targeting a strict
   language. To test this hypothesis we did a case-study of implementations of
   red/black-trees in Agda as well as three reference implementations in Haskell
   emulating dependent types to varying degrees.


* Implementation
  The project is designed to fit into the "Agda framework". Agda has a notion of
  a =Backend= which is essentially what we have designed.

  Our compiler translates Treeless[^1] to [malfunction]:

  #+BEGIN_QUOTE
  Malfunction is an untyped program representation intended as a compilation
  target for functional languages, consisting of a thin wrapper around OCaml’s
  Lambda intermediate representation.
  #+END_QUOTE [dolan-2016]

  Our backend does whole-module compilation. All definitions are pulled into
  scope and output into the same malfunction module.

  The UI of our compiler needs a bit of polishing, but essentially you invoke it
  like so:

  #+BEGIN_EXAMPLE
  agda2mlf --mlf $SRC --compilemlf=$EXE
  #+END_EXAMPLE

  Where =$SRC= is your source-file and =$EXE= is the resulting executable.
  =--mlf= tells Agda to invoke the malfunction backend.

  [^1]: Treeless is an intermediate representation of Agda.
  [malfunction]: https://github.com/stedolan/malfunction
  [dolan-2016]: Dolan, Stephen; "Malfunction Programming" 2016.

  # Describe design-considerations and challenges and limitations (backlog)
** Module overview

   The strong connection with Agda is reflected in the layout of the modules:

  * =Agda.Compiler.Malfunction=

    Exports a =Backend= used by the Agda-framework.

  * =Agda.Compiler.Malfunction.AST=

    Definition of the malfunction syntax.

  * =Agda.Compiler.Malfunction.Compiler=

    The main implementation of the compiler.

  * =Agda.Compiler.Malfunction.Instances=

    Not currently being used.

  * =Agda.Compiler.Malfunction.Main=

    Utility used in our project to invoke Agda. Will become redundant when merged into Agda.

  * =Agda.Compiler.Malfunction.Primitive=

    Maps names of primitives and axioms to their malfunction implementation.
    Will be obsoleted once support for for the pragmas =COMPILE= and =FOREIGN=
    are implemented.

  * =Agda.Compiler.Malfunction.Run=

    Various utilities used for development and testing.

** Features and limitations
   Our efforts with this project have gone specifially towards getting an
   implementation of red/black trees to compile and as such have provided a
   direct guide for our efforts. The current implementation is able to compile
   the program =RedBlack.agda= (presented later). This program imports the agda
   prelude[^2] which contains a decent amount of Agda code. It should be said
   though that this does not mean that all parts of the Agda prelude will work
   with our compiler. Far from it. But it does give us a fair amount of
   confidence that we are able to translate Treeless correctly. The reason most
   of the stuff from the Agda prelude will not work is due to the limited
   support for primitives

*** Primitives
   When we started our project we decided to keep things simple and not use a
   parser-generator because we didn't see the need for parsing malfunction
   syntax. This means that we've written the AST by hand and an instance of
   =Pretty= (for translating to concrete syntax) by hand.

   The lack of support for parsing malfunction means that we also have not
   included support for the new Agda pragmas =COMPILE= and =FOREIGN= that
   essentially map fundamental operations to their counterparts in the target
   language. Our implementation in stead makes use of a hack. We've manually
   written this mapping for a few reserved names, and only the ones we happened
   to need for the red-black examples. This means, amongst other things that you
   cannot do IO with our backend.

*** Lazyness/strictness
    The behaviour of programs change when using this backend. This is a
    consequence of using strict evaluation. Consider the program

    #+BEGIN_SRC treeless
    {-# TERMINATING #-}
    fac : Nat -> Nat
    fac 0 = 1
    fac n = fac (n - 1) * suc n
    #+BEGIN_SRC

    #+BEGIN_SRC treeless
    example.fac =
      \ a →
        let b = t.fac (Agda.Builtin.Nat._-_ a 1) * (1 + a) in
        case a of
          0 → 1
          _ → b
    #+BEGIN_SRC

    Note 2 things: We've disabled the termination-checker (and are therefore
    asking for trouble) and also note that the binding-site of =b= is outside
    the case-expression (allowing it to postentially be used across branches).
    This means that evaluating the treeless in a strict setting would result in
    a divergent computation which would not occur in a lazy setting. Our
    compiler does not try to fix this by pusing the let-binding down the
    expression tree.

    We disabled the termination checker, but a similar example could be given
    for which termnation *can* be guaranteed but where the value may not be
    needed. In this case the resulting program would converge, but be slower.

*** Tail-recursion
    We also uncovered an issue with our implementation relating to non-
    tail-recursive functions that resulted in a stack-overflow with our backend
    that was not exhibited by MAlonzo. This may be due to some optimization
    provided by ghc that is not provided by malfunciton, but this is not known
    to us at this time.

    In testing the implementation of RedBlack we needed a helper function =downFrom=:

    #-BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom 0       = []
    downFrom (suc n) = n :: downFrom n
    #-END_SRC

    =downFrom n= will cause a stack-overflow for sufficiently high =n=. We
    changed this function to:

    #-BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom = f []
      where
        f : List Nat -> Nat -> List Nat
        f xs 0 = xs
        f xs (suc x) = f ( x :: xs ) x
    #-END_SRC

# We exposed a "bug" that has to do with the order (the depth) of let-bindings in
# treeless.

# "all programs that terminate in a strict semantic terminate in a lazy
# semantic, but not the other way around" - jan mas
# Example:
#     
# Tail recursion problem

   [^2]: https://github.com/UlfNorell/agda-prelude

* Red/Black-tree
  # Briefly describe red-black algorithm and give a brief overview of how dependent
  # types can be helpful in this domain. Compare the different implementations
** Description
   * A red-black tree is a balanced binary search tree which nodes are either red
     or black.
   * By constraining the color of the nodes a red-black tree ensures
     that the longest path from the root to a leaf is not more than twice as long
     as the shortest path from the root to a leaf.
   * It is a widely used data structure. For instance, it is used in the =C++=
     Standard Template Library for sorted sets and maps.
** Properties
    A red-black tree has the following properties:
    1. Every node is either \textcolor{red}{red} or \textbf{black}.
    2. The root node is \textbf{black}.
    3. Every leaf is \textbf{black}.
    4. If a node is \textcolor{red}{red}, then its children must be \textbf{black}.
    5. For each node, all paths from the node to descendant leaves contain the
       same number of \textbf{black} nodes.
** Example
    #+ATTR_LATEX: :width \textwidth :float
    #+CAPTION: A red-black tree.
    #+NAME:   fig:redblack
    [[./img/redblack.png]]

** Algorithm
   For benchmarking we used an implementation in Agda using dependent types and
   three haskell-versions that "emulate" dependent types to varying degrees by
   using various language-extenssions. All implementations are based on
   [okasaki-1993]. The implementation of the Agda version is an adaptation of
   the one from [brady-2005]. The three haskell-versions are slightly modified
   versions of the ones found in [kahr-2001] (downloadable from
   [kahrs-homepage]).

   The first haskell-implementation is the straight-forward implementation
   presented by Okasaki and does not encode tree-invariants in its type. The
   second haskell implementation uses *nested higher-order types* and the last
   uses *existential types*.

   We won't go into greater detail with the implementation-details but refer
   interested readers to the resources cited above.

   We also present a slight variant on the Agda version. One where =fromList= is
   implemented using a lazy- and strict- fold respectively. We expect that this
   change won't have an impact on the version compiled using the OCaml backend,
   but would expect a speed-up in the strict variant using the Haskell-variant.

   [okasaki-1993]:   Okasaki, Chris; "Red-Black Trees in a Functional Setting", 1993

   [brady-2005]:     Brady, Edwin C.; "Practical Implementation of a Dependently
                     Typed Functional Programming Language", 2005

   [kahr-2001]:      Kahrs, Stefan Michael; "Red-black trees with types", 2001

   [kahrs-homepage]: https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html
                     Downloaded: 2017-03-21 10:23

* Benchmarks
  # Describe tests and test-results, compare result from Agda backend and the
  # Haskell versions that to varying degree try to emulate some dependent-types
  For our benchmarks we tested the following variants:

  * An Agda implementation using a lazy   fold compiled to Haskell
  * An Agda implementation using a strict fold compiled to Haskell
  * An Agda implementation using a lazy   fold compiled to OCaml
  * An Agda implementation using a strict fold compiled to OCaml
  * A Haskell implementation
  * A Haskell implementation using nested higher-order types
  * A Haskell implementation using existential types

  We also varied; 1) the length of the list and 2) the sorted-ness of the lists
  (sorted, reversed, randomized). WARNING HYPOTHESIS: We did not see any
  variation based on the "sortedness" so we just present these results:

  # WARNING HYPOTHESIS:
  We can see that the OCaml backend versions have similar performance
  characteristics, and we can further see that they are similarly performant to
  the performance characteristics of the haskell version with a strict fold.

  Quite surprisingly the Haskell versions all perform worse than the Agda
  implementation. We suspect this may be an issue with the implementations, but
  we can't explain this.

  # TODO: Incorporate:
  # The expensive part in the haskell implementations seem to do with how the
  # lists are generated and summed.

  # TODO: Incorporate:
  # Looking at the profiler output we see that =fromList= accounts for ~95% of
  # the execution time. We don't have the luxury of inspecting this value in the
  # Agda-implementations but we expect that it's similar.

* Discussion
  # What have we learned. Is the compiler we wrote the one to rule the all?
  The difference in implementation of the lazy- and strict-versions of the
  red/black-algorithm in Agda boils down to the addition of a single character.
  So in this example writing a more strict and better performing immplementation
  using the Haskell backend requires a trivial change. Of course identifying
  where to use and where not to use strictness in a lazy setting may not be as
  easy as in this case.

  Compiling to a language with strict call-semantics means that "adding
  strictness" shouldn't have much of an impact on the resulting program, and
  indeed we implemented =seq= like so:

  #-BEGIN_EXAMPLE
  seq _ a = a
  #-END_EXAMPLE

  Strictness forced us to reformulate parts of the program to avoid a
  stack-overflow when constructing the red-black tree. Similarly we reformulated
  explicitly added a strict fold to gain a performance boost in the using the
  MAlonzo backend. This highlights that there are different things to be aware
  of depending on which call-semantics you are writing a program for. We also
  conclude that the example illustrates the benefit of using strict evaluation
  but also that it may be easy to acheive similar effects using the MAlonzo
  backend.

  As we've already mentioned our compiler suffers from some limitations due to
  lack of support for mapping primitives to the host-languages. This means that
  there are features that we've not been able to compare but at least in the
  case of the red/black-algorithm we've managed to make an implementation that
  is not slower than it's counterpart using the Haskell backend.

* Perspectives
  # What further work could be done?
  Further effort should be put into figuring out why the haskell implementations
  are running so slowly.

  Further work should be put into figuring out why we get a stack-overflow when
  using =foldr=.

  In our backlog for the compiler we have the folling things:

  * Support for =COMPILE= and =FOREGIN= pragma.
  * Merge codebase into Agda

* Conclusion
We have presented our work with implementing a new backedn
