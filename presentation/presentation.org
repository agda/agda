#+BEAMER_THEME: default
#+BEAMER_COLOR_THEME: default
#+TITLE: An strict backend for Agda
#+SUBTITLE: agda2mlf
#+AUTHOR: Frederik Hanghøj Iversen, Jan Mas Rovira
#+OPTIONS: H:2
#+DATE: \today

* Introduction
  # Describe design-considerations and challenges and limitations (backlog)
** Introduction
   We present our efforts to implement a backend for Agda targeting OCaml. We
   present some of the problems we ran into along the way as well as limitations
   of the current implementation. The motivation for the project was to explore
   if it was possible to gain a performance boost by targeting a strict
   language. To test this hypothesis we did a case-study of implementations of
   red/black-trees in Agda as well as three reference implementations in Haskell
   emulating dependent types to varying degrees.


* Implementation
  The project is designed to fit into the "Agda framework". Agda has a notion of
  a =Backend= which is essentially what we have designed.

  Our compiler translates Treeless[^1] to [malfunction]:

  #+BEGIN_QUOTE
  Malfunction is an untyped program representation intended as a compilation
  target for functional languages, consisting of a thin wrapper around OCaml’s
  Lambda intermediate representation.
  #+END_QUOTE [dolan-2016]

  Our backend does whole-module compilation. All definitions are pulled into
  scope and output into the same malfunction module.

  The UI of our compiler needs a bit of polishing, but essentially you invoke it
  like so:

  #+BEGIN_EXAMPLE
  agda2mlf --mlf $SRC --compilemlf=$EXE
  #+END_EXAMPLE

  Where =$SRC= is your source-file and =$EXE= is the resulting executable.
  =--mlf= tells Agda to invoke the malfunction backend.

  [^1]: Treeless is an intermediate representation of Agda.
  [malfunction]: https://github.com/stedolan/malfunction
  [dolan-2016]: Dolan, Stephen; "Malfunction Programming" 2016.

  # Describe design-considerations and challenges and limitations (backlog)
** Module overview

   The strong connection with Agda is reflected in the layout of the modules:

  * =Agda.Compiler.Malfunction=

    Exports a =Backend= used by the Agda-framework.

  * =Agda.Compiler.Malfunction.AST=

    Definition of the malfunction syntax.

  * =Agda.Compiler.Malfunction.Compiler=

    The main implementation of the compiler.

  * =Agda.Compiler.Malfunction.Instances=

    Not currently being used.

  * =Agda.Compiler.Malfunction.Main=

    Utility used in our project to invoke Agda. Will become redundant when merged into Agda.

  * =Agda.Compiler.Malfunction.Primitive=

    Maps names of primitives and axioms to their malfunction implementation.
    Will be obsoleted once support for for the pragmas =COMPILE= and =FOREIGN=
    are implemented.

  * =Agda.Compiler.Malfunction.Run=

    Various utilities used for development and testing.

** Features and limitations
   Our efforts with this project have gone specifially towards getting an
   implementation of red/black trees to compile and as such have provided a
   direct guide for our efforts. The current implementation is able to compile
   the program =RedBlack.agda= (presented later). This program imports the agda
   prelude[^2] which contains a decent amount of Agda code. It should be said
   though that this does not mean that all parts of the Agda prelude will work
   with our compiler. Far from it. But it does give us a fair amount of
   confidence that we are able to translate Treeless correctly. The reason most
   of the stuff from the Agda prelude will not work is due to the limited
   support for primitives

*** Primitives
   When we started our project we decided to keep things simple and not use a
   parser-generator because we didn't see the need for parsing malfunction
   syntax. This means that we've written the AST by hand and an instance of
   =Pretty= (for translating to concrete syntax) by hand.

   The lack of support for parsing malfunction means that we also have not
   included support for the new Agda pragmas =COMPILE= and =FOREIGN= that
   essentially map fundamental operations to their counterparts in the target
   language. Our implementation in stead makes use of a hack. We've manually
   written this mapping for a few reserved names, and only the ones we happened
   to need for the red-black examples. This means, amongst other things that you
   cannot do IO with our backend.

*** Lazyness/strictness
    The behaviour of programs change when using this backend. This is a
    consequence of using strict evaluation. Consider the program

    #+BEGIN_SRC treeless
    {-# TERMINATING #-}
    fac : Nat -> Nat
    fac 0 = 1
    fac n = fac (n - 1) * suc n
    #+BEGIN_SRC

    #+BEGIN_SRC treeless
    example.fac =
      \ a →
        let b = t.fac (Agda.Builtin.Nat._-_ a 1) * (1 + a) in
        case a of
          0 → 1
          _ → b
    #+BEGIN_SRC

    Note 2 things: We've disabled the termination-checker (and are therefore
    asking for trouble) and also note that the binding-site of =b= is outside
    the case-expression (allowing it to postentially be used across branches).
    This means that evaluating the treeless in a strict setting would result in
    a divergent computation which would not occur in a lazy setting. Our
    compiler does not try to fix this by pusing the let-binding down the
    expression tree.

    We disabled the termination checker, but a similar example could be given
    for which termnation *can* be guaranteed but where the value may not be
    needed. In this case the resulting program would converge, but be slower.

*** Tail-recursion
    We also uncovered an issue with our implementation relating to non-
    tail-recursive functions that resulted in a stack-overflow with our backend
    that was not exhibited by MAlonzo. This may be due to some optimization
    provided by ghc that is not provided by malfunciton, but this is not known
    to us at this time.

    In testing the implementation of RedBlack we needed a helper function =downFrom=:

    #-BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom 0       = []
    downFrom (suc n) = n :: downFrom n
    #-END_SRC

    =downFrom n= will cause a stack-overflow for sufficiently high =n=. We
    changed this function to:

    #-BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom = f []
      where
        f : List Nat -> Nat -> List Nat
        f xs 0 = xs
        f xs (suc x) = f ( x :: xs ) x
    #-END_SRC

# We exposed a "bug" that has to do with the order (the depth) of let-bindings in
# treeless.

# "all programs that terminate in a strict semantic terminate in a lazy
# semantic, but not the other way around" - jan mas
# Example:
#     
# Tail recursion problem

   [^2]: https://github.com/UlfNorell/agda-prelude

* Red/Black-tree
  # Briefly describe red-black algorithm and give a brief overview of how dependent
  # types can be helpful in this domain. Compare the different implementations
** Description
   * A red-black tree is a balanced binary search tree which nodes are either red
     or black.
   * By constraining the color of the nodes a red-black tree ensures
     that the longest path from the root to a leaf is not more than twice as long
     as the shortest path from the root to a leaf.
   * It is a widely used data structure. For instance, it is used in the =C++=
     Standard Template Library for sorted sets and maps.
** Properties
    A red-black tree has the following properties:
    1. Every node is either \textcolor{red}{red} or \textbf{black}.
    2. The root node is \textbf{black}.
    3. Every leaf is \textbf{black}.
    4. If a node is \textcolor{red}{red}, then its children must be \textbf{black}.
    5. For each node, all paths from the node to descendant leaves contain the
       same number of \textbf{black} nodes.
** Example
    #+ATTR_LATEX: :width \textwidth :float
    #+CAPTION: A red-black tree.
    #+NAME:   fig:redblack
    [[./img/redblack.png]]

** Algorithm
   For benchmarking we used an implementation in Agda using dependent types and
   three haskell-versions that "emulate" dependent types to varying degrees by
   using various language-extenssions. All implementations are based on
   [okasaki-1993]. The implementation of the Agda version is an adaptation of
   the one from [brady-2005]. The three haskell-versions are slightly modified
   versions of the ones found in [kahr-2001] (downloadable from
   [kahrs-homepage]).

   The first haskell-implementation is the straight-forward implementation
   presented by Okasaki and does not encode tree-invariants in it's type. The
   second haskell implementation uses *nested higher-order types* and the last
   uses *existential types*.

   We won't go into greater detail with the implementation-details but refer
   interested readers to the resources cited above.

   We also present a slight variant on the Agda version. One where =fromList= is
   implemented using a lazy- and strict- fold respectively. We expect that this
   change won't have an impact on the version compiled using the OCaml backend,
   but would expect a speed-up in the strict variant using the Haskell-variant:

   [okasaki-1993]:   Okasaki, Chris; "Red-Black Trees in a Functional Setting", 1993

   [brady-2005]:     Brady, Edwin C.; "Practical Implementation of a Dependently
                     Typed Functional Programming Language", 2005

   [kahr-2001]:      Kahrs, Stefan Michael; "Red-black trees with types", 2001

   [kahrs-homepage]: https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html
                     Downloaded: 2017-03-21 10:23

* Benchmarks
  # Describe tests and test-results, compare result from Agda backend and the
  # Haskell versions that to varying degree try to emulate some dependent-types

* Discussion
  # What have we learned. Is the compiler we wrote the one to rule the all?

* Perspectives
  # What further work could be done?
