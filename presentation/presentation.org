#+BEAMER_THEME: default
#+BEAMER_COLOR_THEME: default
#+TITLE: A strict backend for Agda
#+SUBTITLE: agda2mlf
#+AUTHOR: Frederik Hanghøj Iversen, Jan Mas Rovira
#+OPTIONS: H:2
#+DATE: \today

* Introduction
  # Describe design-considerations and challenges and limitations (backlog)
** Introduction
*** Faster Agda
*** Backend targeting the OCaml Compiler
*** Case-study: Red/black trees
*** Benchmarks
*** Further work
* Implementation
** Implementation
*** Hooks into the Agda framework, define a new backend
*** Translate from Treeless to Malfunction
  #+BEGIN_QUOTE
  Malfunction is an untyped program representation intended as a compilation
  target for functional languages, consisting of a thin wrapper around OCaml’s
  Lambda intermediate representation.[fn:dolan-2016]
  #+END_QUOTE

[fn:dolan-2016] Dolan, Stephen; "Malfunction Programming" 2016.

*** Whole-module compilation


  # Describe design-considerations and challenges and limitations (backlog)
** Module overview

  * =Agda.Compiler.Malfunction=

    Exports a =Backend= used by the Agda-framework.

  * =Agda.Compiler.Malfunction.AST=

  * =Agda.Compiler.Malfunction.Compiler=

    The main implementation of the compiler.

  * =Agda.Compiler.Malfunction.Instances=

  * =Agda.Compiler.Malfunction.Main=

  * =Agda.Compiler.Malfunction.Primitive=

  * =Agda.Compiler.Malfunction.Run=

** Features and limitations

*** Red/black as a guide
    Compiles the red/black algorithm which uses the Agda
    Prelude[fn:agda-prelude]. This gives us confidence that we have decent
    coverage of the Treeless language.

[fn:agda-prelude] https://github.com/UlfNorell/agda-prelude

*** Primitives
    Cannot parse Malfunction, so there is not support for the =COMPILE= and
   =FOREIGN= pragmas. The only primitives that are mapped are a small subset
   that makes the red/black example run.

** Features and limitations (contd.)
*** Lazyness/strictness
    The behaviour of programs change when using this backend.

    #+BEGIN_SRC agda
    {-# TERMINATING #-}
    fac : Nat -> Nat
    fac 0 = 1
    fac n = fac (n - 1) * suc n
    #+END_SRC

    #+BEGIN_SRC treeless
    example.fac =
      \ a →
        let b = t.fac (Agda.Builtin.Nat._-_ a 1) * (1 + a) in
        case a of
          0 → 1
          _ → b
    #+END_SRC

** Features and limitations (contd.)
*** Tail-recursion
    In testing the implementation of RedBlack we needed a helper function =downFrom=:

    #+BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom 0       = []
    downFrom (suc n) = n :: downFrom n
    #+END_SRC

    =downFrom n= will cause a stack-overflow for sufficiently high =n=. We
    changed this function to:

    #+BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom = f []
      where
        f : List Nat -> Nat -> List Nat
        f xs 0 = xs
        f xs (suc x) = f ( x :: xs ) x
    #+END_SRC


* Red/Black-tree
** Description
   A red-black tree is a balanced binary search tree which nodes are either red
   or black.

   \vspace{0.3cm}

   By constraining the color of the nodes a red-black tree ensures that the
   longest path from the root to a leaf is not more than twice as long as the
   shortest path from the root to a leaf.

   \vspace{0.3cm}

   It is a widely used data structure. For instance, it is used in the =C++=
   Standard Template Library for sorted sets and maps.
** Properties
    A red-black tree has the following properties:
    1. Every node is either red or black.
    2. The root node is black.
    3. Every leaf is black.
    4. If a node is red, then its children must be black.
    5. For each node, all paths from the node to descendant leaves contain the
       same number of black nodes.
** Example
    #+ATTR_LATEX: :width \textwidth :float
    #+CAPTION: A red-black tree.
    #+NAME:   fig:redblack
    [[./img/redblack.png]]

** Implementations
   All implementations are based on [fn:okasaki-1993]. The implementation of the
   Agda version is an adaptation of the one from [fn:brady-2005]. The three
   haskell-versions are slightly modified versions of the ones found in
   [fn:kahr-2001].

   The Haskell implementation use:

   1. Straight-forward implementation
   2. Nested higher-order types
   3. Existential types

   We also tested a slight variation on the Agda version, one where we used
   explicit strictness and one where we didn't.

[fn:okasaki-1993]:   Okasaki, Chris; "Red-Black Trees in a Functional Setting", 1993

[fn:brady-2005]:     Brady, Edwin C.; "Practical Implementation of a Dependently
                     Typed Functional Programming Language", 2005

[fn:kahr-2001]:      Kahrs, Stefan Michael; "Red-black trees with types", 2001

* Benchmarks
** Procedure
  For our benchmarks we tested the following variants:

  * An Agda implementation using a lazy   fold compiled to Haskell
  * An Agda implementation using a strict fold compiled to Haskell
  * An Agda implementation using a lazy   fold compiled to OCaml
  * An Agda implementation using a strict fold compiled to OCaml
  * A Haskell implementation
  * A Haskell implementation using nested higher-order types
  * A Haskell implementation using existential types

  We also varied; 1) the length of the list and 2) the sortedness of the lists
  (sorted, reversed sorted, randomized). For the randomized lists we used the
  Blum Blum Shub pseudo-random number generation algorithm to generate
  (pseudo-)randmoized lists. The advantage of using this approach is the the
  results are deterministic, and therefore reproducible, and it is fairly easy
  to compute.

  We used the C Preprocessor to handle these different variants. So the programs
  do not do any input. All tests procede by sorting a list using
  =toList . fromList=, so converting to and from a red/black tree and then summing the
  resulting list. Profiling output from the Haskell-implementations show us that
  the largest cost-center (around 95%) is the generation of the tree. We do not
  have access to similar resources for the Agda implementations but we don't
  expect that the picture should be any different here.

  # TODO: talk about how sortedness effects the performance. In the random case
  # the MAlonzo backend performs worse.

** Results
   # TODO: Include graphs, explain findings
*** Summing sorted lists
    [[./img/sum_sorted.pdf]]
    # TODO: Jan revise
    Result: We see that haskell uses constant memory and is a lot faster than the agda-version.
    Malfunction version is faster than MAlonzo.
    Jan: "Optimization stuff"
    We also did a benchmark with reversed lists, the results look similar.

*** Summing random lists
  Here the Malfunction implementation is the fastest.

  We see that Haskell is still about as fast as the Malfunction implementation.

  Furthermore we see that adding (pseudo-)randomization to the generation of the
  list, has an impact on the performance on the Haskell version, but it still
  ranks as one of the fastest implementations.

*** Summing and tree-sorting random lists

  We can see that the strict- and lazy Malfunction-versions have a very similar
  performance[fn::In fact, we know that they compile to the same program. See
  section [[[[sec:discussion]]]]] characteristics, and we can further see that they
  perform similarly to the MAlonzo version with a strict fold.

  Quite surprisingly the Haskell versions all perform worse thasn the Agda
  implementations. We suspect this may be an issue with how the red/black
  algorithm was implemented.

  We also see that the Malfunction backend performs better than the MAlonzo
  backend.

* Discussion
  <<sec:discussion>>

  # TODO: clarify
  The difference in implementation of the lazy- and strict-versions of the
  red/black-algorithm in Agda boil down to how =fromList= is implemented:

  #+BEGIN_SRC agda
  fromList = foldl! (flip insert) (mkT leaf)
  #+BEGIN_SRC

  #+BEGIN_SRC agda
  fromList = foldl  (flip insert) empty
  fromList = foldr insert empty
  #+BEGIN_SRC

  So in this example writing a more strict and better performing immplementation
  using the Haskell backend requires a trivial change. Of course identifying
  where to use and where not to use strictness in a lazy setting may not be as
  easy as in this case.

  Compiling to a language with strict call-semantics means that "adding
  strictness" should have close to no impact on the resulting program, and
  indeed we implemented =seq= like so:

  #-BEGIN_EXAMPLE
  seq _ a = a
  #-END_EXAMPLE

  Strictness forced us to reformulate parts of the program to avoid a
  stack-overflow when constructing the red-black tree. Similarly we explicitly
  added a strict fold to gain a performance boost when using the MAlonzo
  backend. This highlights that there are different things to be aware of
  depending on which call-semantics you are writing a program for. We also
  conclude that the example illustrates the benefit of using strict evaluation
  but also that it may be easy to achieve similar effects using the MAlonzo
  backend.

  As we've already mentioned our compiler suffers from some limitations due to
  lack of support for mapping primitives to the host-languages. This means that
  there are features that we've not been able to compare but at least in the
  case of the red/black-algorithm we've shown that compiling using the
  Malfunction backend generates roughly twice as fast a program than using the
  MAlonzo backend.
  # TODO: revise 'twice as fast' claim

* Perspectives
** Perspectives
  Why are the Haskell implementations so slow?

  \vspace{0.3cm}

  Further work should be put into figuring out why we get a stack-overflow when
  using =foldr=.

   \vspace{0.3cm}

 To be able to more confidently compare the efficiency of the executables
  produced by our compiler benchmark of more algorithms would be useful.

   \vspace{0.3cm}

 It would be desirable to have support for =COMPILE= and =FOREGIN= pragma.

   \vspace{0.3cm}

 The compiler should ideally be merged into the Agda codebase.

   \vspace{0.3cm}

 Adding optimizations to the compiler would also be beneficial.

* Conclusion
** Conclusion
    Successfully implemented a compiler.

    \vspace{0.3cm}

    Limited support for primitives.
    
    \vspace{0.3cm}

    Seems to outperform MAlonzo and Haskell reference implementations.

    \vspace{0.3cm}

    Benchmark of more algorithms should be performed.
