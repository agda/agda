#+BEAMER_THEME: default
#+BEAMER_COLOR_THEME: default
#+TITLE: A strict backend for Agda
#+SUBTITLE: agda2mlf
#+AUTHOR: Frederik Hanghøj Iversen, Jan Mas Rovira
#+OPTIONS: H:2
#+DATE: \today

* Introduction
  # Describe design-considerations and challenges and limitations (backlog)
** Introduction
*** Faster Agda
*** Backend targeting the OCaml Compiler
*** Case-study: Red/black trees
*** Benchmarks
*** Further work
* Implementation
** Implementation
*** Hooks into the Agda framework, define a new backend
*** Translate from Treeless to Malfunction
  #+BEGIN_QUOTE
  Malfunction is an untyped program representation intended as a compilation
  target for functional languages, consisting of a thin wrapper around OCaml’s
  Lambda intermediate representation.[fn:dolan-2016]
  #+END_QUOTE

[fn:dolan-2016] Dolan, Stephen; "Malfunction Programming" 2016.

*** Whole-module compilation


  # Describe design-considerations and challenges and limitations (backlog)
** Module overview

  * =Agda.Compiler.Malfunction=

    Exports a =Backend= used by the Agda-framework.

  * =Agda.Compiler.Malfunction.AST=

  * =Agda.Compiler.Malfunction.Compiler=

    The main implementation of the compiler.

  * =Agda.Compiler.Malfunction.Instances=

  * =Agda.Compiler.Malfunction.Main=

  * =Agda.Compiler.Malfunction.Primitive=

  * =Agda.Compiler.Malfunction.Run=

** Features and limitations

*** Red/black as a guide
    Compiles the red/black algorithm which uses the Agda
    Prelude[fn:agda-prelude]. This gives us confidence that we have decent
    coverage of the Treeless language.

[fn:agda-prelude] https://github.com/UlfNorell/agda-prelude

*** Primitives
    Cannot parse Malfunction, so there is not support for the =COMPILE= and
   =FOREIGN= pragmas. The only primitives that are mapped are a small subset
   that makes the red/black example run.

** Features and limitations (contd.)
*** Lazyness/strictness
    The behaviour of programs change when using this backend.

    #+BEGIN_SRC agda
    {-# TERMINATING #-}
    fac : Nat -> Nat
    fac 0 = 1
    fac n = fac (n - 1) * suc n
    #+END_SRC

    #+BEGIN_SRC treeless
    example.fac =
      \ a →
        let b = t.fac (Agda.Builtin.Nat._-_ a 1) * (1 + a) in
        case a of
          0 → 1
          _ → b
    #+END_SRC

** Features and limitations (contd.)
*** Tail-recursion
    In testing the implementation of RedBlack we needed a helper function =downFrom=:

    #+BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom 0       = []
    downFrom (suc n) = n :: downFrom n
    #+END_SRC

    =downFrom n= will cause a stack-overflow for sufficiently high =n=. We
    changed this function to:

    #+BEGIN_SRC agda
    downFrom : Nat -> List Nat
    downFrom = f []
      where
        f : List Nat -> Nat -> List Nat
        f xs 0 = xs
        f xs (suc x) = f ( x :: xs ) x
    #+END_SRC


* Red/Black-tree
** Description
   A red-black tree is a balanced binary search tree which nodes are either red
   or black.

   \vspace{0.3cm}

   By constraining the color of the nodes a red-black tree ensures that the
   longest path from the root to a leaf is not more than twice as long as the
   shortest path from the root to a leaf.

   \vspace{0.3cm}

   It is a widely used data structure. For instance, it is used in the =C++=
   Standard Template Library for sorted sets and maps.
** Properties
    A red-black tree has the following properties:
    1. Every node is either red or black.
    2. The root node is black.
    3. Every leaf is black.
    4. If a node is red, then its children must be black.
    5. For each node, all paths from the node to descendant leaves contain the
       same number of black nodes.
** Example
    #+ATTR_LATEX: :width \textwidth :float
    #+CAPTION: A red-black tree.
    #+NAME:   fig:redblack
    [[./img/redblack.png]]

** Implementations
   All implementations are based on [fn:okasaki-1993]. The implementation of the
   Agda version is an adaptation of the one from [fn:brady-2005]. The three
   haskell-versions are slightly modified versions of the ones found in
   [fn:kahr-2001].

   The Haskell implementation use:

   1. Straight-forward implementation
   2. Nested higher-order types
   3. Existential types

   We also tested a slight variation on the Agda version, one where we used
   explicit strictness and one where we didn't.

[fn:okasaki-1993]:   Okasaki, Chris; "Red-Black Trees in a Functional Setting", 1993

[fn:brady-2005]:     Brady, Edwin C.; "Practical Implementation of a Dependently
                     Typed Functional Programming Language", 2005

[fn:kahr-2001]:      Kahrs, Stefan Michael; "Red-black trees with types", 2001

* Benchmarks

** Procedure
   We benchmarked two algorithms:
   1. The sum of a list.
   2. Sorting a list using a red-black tree and then summing it.

  # We also varied; 1) the length of the list and 2) the sortedness of the lists
  # (sorted, reversed sorted, randomized). For the randomized lists we used the
  # Blum Blum Shub pseudo-random number generation algorithm to generate
  # (pseudo-)randmoized lists. The advantage of using this approach is the the
  # results are deterministic, and therefore reproducible, and it is fairly easy
  # to compute.

  # We used the C Preprocessor to handle these different variants. So the programs
  # do not do any input. All tests procede by sorting a list using
  # =toList . fromList=, so converting to and from a red/black tree and then summing the
  # resulting list. Profiling output from the Haskell-implementations show us that
  # the largest cost-center (around 95%) is the generation of the tree. We do not
  # have access to similar resources for the Agda implementations but we don't
  # expect that the picture should be any different here.

  # TODO: talk about how sortedness effects the performance. In the random case
  # the MAlonzo backend performs worse.
** Summing sorted lists
   Implementations:
   1. Agda/MAlonzo with and without tail recursion.
   2. Agda/Malfunction using tail recursion. Stack overflow without tail recursion!
   3. Haskell with and without tail recursion.
** Summing sorted lists
   Generation lists:
   #+BEGIN_SRC haskell
     -- Non-tail recursive
     fromTo, fromTo' :: Int -> [Int]
       fromTo n = f n
         where
           f 0 = []
           f x = n - x + 1 : f (x - 1)

       -- Tail recursive using a bang pattern
       -- The Agda version uses seq
       fromTo' = f []
         where
           f xs 0 = xs
           f !xs x = f (x : xs) (x - 1)
   #+END_SRC
   The sum function is always tail recursive.
** Summing sorted lists (result)
   [[./img/sum_sorted.pdf]]
   # We see that non-tail recursive Haskell version is
   # greatly optimized and it uses constant memory, consequently, is a lot faster than all
   # the other versions. Both MAlonzo versions and the tail recursive Haskell
   # version perform very similarly. Malfunction version is faster than MAlonzo.
   # The Malfunction version is better that the MAlonzo backend but not as fast
   # as the best non-tail recursive Haskell version.

   # We also did a benchmark with reversed lists, the results look similar.

** Tree-sorting and summing random lists
   For the red-black tree benchmark we have the following variants:
  * An Agda implementation compiled to Haskell using MAlonzo and to Malfunction
    using our backend.
  * A Haskell implementation without advanced types.
  * A Haskell implementation using nested higher-order types.
  * A Haskell implementation using existential types.

    We benchmarked each implementation using sorted lists and random lists.
** Tree-sorting and summing random lists
    #+BEGIN_SRC haskell
    fromList, fromList' :: Ord a => [a] -> Tree a
    fromList = foldr insert empty
    fromList' = foldl' (flip insert) empty

    bench = sum . toList . fromList . genList
    #+END_SRC
    #+BEAMER: \pause
    The most costly part is creating the tree:
    #+BEGIN_EXAMPLE
                     inherited
  COST CENTRE        %time  %alloc
    ...
   fromList          94.9   91.0
    insert           91.6   80.9
    ...
    #+END_EXAMPLE

** Tree-sorting and summing random lists
   #+CAPTION: Treesorting and summing a random list.
   #+ATTR_LATEX: :float
   [[./img/treesort_rand_all.pdf]]



** Tree-sorting and summing a long sorted list
   #+CAPTION: Treesorting and summing a long sorted list.
   #+ATTR_LATEX: :float
   [[./img/treesort_sorted_best.pdf]]
   In this benchmark the Malfunction backend performs about twice as fast as the MAlonzo backend.

** Tree-sorting and summing a long random list
   #+CAPTION: Treesorting and summing a long random list.
   #+ATTR_LATEX: :float
   [[./img/treesort_rand_best.pdf]]
   We also see that the Malfunction backend performs about ten times faster than the MAlonzo
   backend.
* Perspectives
** Perspectives
   * Why are the Haskell implementations so slow?
   * To be able to more confidently compare the efficiency of the executables
     produced by our compiler benchmark of more algorithms would be useful.
   * Further work should be put into figuring out why we get a stack-overflow when
     using =foldr= in Malfunction.
 # It would be desirable to have support for =COMPILE= and =FOREGIN= pragma.
   * There are many potential optimizations for the Malfunction backend.
   * After some more work the compiler should ideally be merged into the Agda
     codebase.

* Conclusion
** Conclusion
    Successfully implemented a compiler.

    \vspace{0.3cm}

    Limited support for primitives.

    \vspace{0.3cm}

    Seems to outperform MAlonzo and Haskell reference implementations.

    \vspace{0.3cm}

    Benchmark of more algorithms should be performed.
