#+LATEX_HEADER: \usepackage[x11names]{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks=true,urlcolor=black,linkcolor=black}
#+LATEX_HEADER: \usepackage[margin=3cm]{geometry}
#+LATEX_HEADER: \usepackage[document]{ragged2e}
#+LATEX_HEADER: \setlength{\parskip}{\baselineskip}
#+TITLE: A strict backend for Agda
#+SUBTITLE: agda2mlf
#+AUTHOR: Frederik Hanghøj Iversen, Jan Mas Rovira
#+OPTIONS: H:3
#+DATE: \today

* Introduction
  # Describe design-considerations and challenges and limitations (backlog)
** Introduction
   We present our efforts to implement a backend for Agda targeting OCaml. We
   present some of the problems we ran into along the way as well as limitations
   of the current implementation. There already exists two backends for Agda.
   The MAlonzo backend that targets ghc and a compiler that targets the
   JavaScript language. The motivation for the project was to explore if it was
   possible to gain a performance boost by targeting a strict language. To test
   this hypothesis we did a case-study of implementations of red/black-trees in
   Agda as well as three reference implementations in Haskell emulating
   dependent types to varying degrees.
* Implementation
  The project is designed to fit into the "Agda framework". Agda has a notion of
  a =Backend= which is essentially what we have designed.

  Our compiler translates Treeless[fn::Treeless is an intermediate representation of Agda.] to [[https://github.com/stedolan/malfunction][malfunction]]:

  #+BEGIN_QUOTE
  Malfunction is an untyped program representation intended as a compilation
  target for functional languages, consisting of a thin wrapper around OCaml’s
  Lambda intermediate representation.[fn:dolan-2016]
  #+END_QUOTE

  Our backend does whole-module compilation. All definitions are pulled into
  scope and output into the same malfunction module.

  The UI of our compiler needs a bit of polishing, but essentially you invoke it
  like so:

  #+BEGIN_EXAMPLE
  agda2mlf --mlf $SRC --compilemlf=$EXE
  #+END_EXAMPLE

  Where =$SRC= is your source-file and =$EXE= is the resulting executable.
  =--mlf= tells Agda to invoke the malfunction backend.

[fn:dolan-2016] Dolan, Stephen; "Malfunction Programming" 2016.

  # Describe design-considerations and challenges and limitations (backlog)
** Module overview

   The strong connection with Agda is reflected in the layout of the modules:

  * =Agda.Compiler.Malfunction=

    Exports a =Backend= used by the Agda-framework.

  * =Agda.Compiler.Malfunction.AST=

    Definition of the malfunction syntax.

  * =Agda.Compiler.Malfunction.Compiler=

    The main implementation of the compiler.

  * =Agda.Compiler.Malfunction.Instances=

    Not currently being used.

  * =Agda.Compiler.Malfunction.Main=

    Utility used in our project to invoke Agda. Will become redundant when merged into Agda.

  * =Agda.Compiler.Malfunction.Primitive=

    Maps names of primitives and axioms to their malfunction implementation.
    Will be obsoleted once support for for the pragmas =COMPILE= and =FOREIGN=
    are implemented.

  * =Agda.Compiler.Malfunction.Run=

    Various utilities used for development and testing.

** Features and limitations
   Our efforts with this project have gone specifially towards getting an
   implementation of red/black trees to compile and as such have provided a
   direct guide for our efforts. The current implementation is able to compile
   the program =RedBlack.agda= (presented later). This program imports the agda
   prelude[fn::https://github.com/UlfNorell/agda-prelude] which contains a decent amount of Agda code. It should be said
   though that this does not mean that all parts of the Agda prelude will work
   with our compiler. But it does give us a fair amount of
   confidence that we are able to translate Treeless correctly. The reason most
   of the stuff from the Agda prelude will not work is due to the limited
   support for primitives.

*** Primitives
   When we started our project we decided to keep things simple and not use a
   parser-generator because we didn't see the need for parsing malfunction
   syntax. This means that we've written the AST by hand and an instance of
   =Pretty= (for translating to concrete syntax) by hand.

   The lack of support for parsing malfunction means that we also have not
   included support for the new Agda pragmas =COMPILE= and =FOREIGN= that
   essentially map fundamental operations to their counterparts in the target
   language. Our implementation instead makes use of a hack. We've manually
   written this mapping for a few reserved names, and only the ones we happened
   to need for the red-black example. This means, amongst other things that you
   cannot do IO with our backend.

*** Lazyness/strictness
    The behaviour of programs change when using this backend. This is a
    consequence of using strict evaluation. Consider the Agda program:

    #+BEGIN_EXAMPLE
    {-# TERMINATING #-}
    fac : Nat -> Nat
    fac 0 = 1
    fac n = fac (n - 1) * suc n
    #+END_EXAMPLE

    This gets translated into treeless.

    #+BEGIN_EXAMPLE
    example.fac =
      \ a →
        let b = t.fac (Agda.Builtin.Nat._-_ a 1) * (1 + a) in
        case a of
          0 → 1
          _ → b
    #+END_EXAMPLE

    Note 2 things: We've disabled the termination-checker (and are therefore
    asking for trouble) and also note that the binding-site of =b= is outside
    the case-expression (allowing it to potentially be used across branches).
    This means that evaluating the treeless program in a strict setting would result in
    a divergent computation which would not occur in a lazy setting. Our
    compiler does not try to fix this by e.g. pushing the let-binding down the
    expression tree.

    We disabled the termination checker, but a similar example could be given
    for which termnation *can* be guaranteed but where the value may not be
    needed. In this case the resulting program would converge, but be slower.
    # TODO: add converving example
*** Tail-recursion
    We also uncovered an issue with our implementation relating to non-
    tail-recursive functions that resulted in a stack-overflow with our backend
    that was not exhibited by MAlonzo. This may be due to some optimization
    provided by ghc that is not provided by malfunction, but this is not known
    to us at this time.

    In testing the implementation of RedBlack we needed a helper function =downFrom=:

    #+BEGIN_EXAMPLE
    downFrom : Nat -> List Nat
    downFrom 0       = []
    downFrom (suc n) = n :: downFrom n
    #+END_EXAMPLE

    =downFrom n= will cause a stack-overflow for sufficiently high =n=. We
    changed this function to:

    #+BEGIN_EXAMPLE
    downFrom : Nat -> List Nat
    downFrom = f []
      where
        f : List Nat -> Nat -> List Nat
        f xs 0 = xs
        f xs (suc x) = f ( x :: xs ) x
    #+END_EXAMPLE

* Red/Black-tree
** Description
   * A red-black tree is a balanced binary search tree which nodes are either red
     or black.
   * By constraining the color of the nodes a red-black tree ensures
     that the longest path from the root to a leaf is not more than twice as long
     as the shortest path from the root to a leaf.
   * It is a widely used data structure. For instance, it is used in the =C++=
     Standard Template Library for sorted sets and maps.
** Properties
    A red-black tree has the following properties:
    1. Every node is either \textcolor{red}{red} or \textbf{black}.
    2. The root node is \textbf{black}.
    3. Every leaf is \textbf{black}.
    4. If a node is \textcolor{red}{red}, then its children must be \textbf{black}.
    5. For each node, all paths from the node to descendant leaves contain the
       same number of \textbf{black} nodes.
** Example
    #+ATTR_LATEX: :width \textwidth :float
    #+CAPTION: A red-black tree.
    #+NAME:   fig:redblack
    [[./img/redblack.png]]

** Implementations
   For benchmarking we used an implementation in Agda using dependent types and
   three haskell-versions that "emulate" dependent types to varying degrees by
   using various language-extenssions. All implementations are based on
   [okasaki-1993][fn:okasaki-1993]. The implementation of the Agda version is an
   adaptation of the one from [brady-2005][fn:brady-2005]. The three haskell-versions are
   slightly modified versions of the ones found in [kahr-2001][fn:kahr-2001] (downloadable
   from [kahrs-homepage][fn:kahrs-homepage]).

   The first haskell-implementation is the straight-forward implementation
   presented by Okasaki and does not encode tree-invariants in its type. The
   second haskell implementation uses *nested higher-order types* and the last
   uses *existential types*.

   We won't go into greater detail with the implementation-details but refer
   interested readers to the resources cited above.

   We also present a slight variant on the Agda version. One where =fromList= is
   implemented using a lazy- and strict- fold respectively. We expect that this
   change won't have an impact on the version compiled using the OCaml backend,
   but would expect a speed-up in the strict variant using the Haskell-variant.

[fn:okasaki-1993]   Okasaki, Chris; "Red-Black Trees in a Functional Setting", 1993

[fn:brady-2005]     Brady, Edwin C.; "Practical Implementation of a Dependently
                    Typed Functional Programming Language", 2005

[fn:kahr-2001]      Kahrs, Stefan Michael; "Red-black trees with types", 2001

[fn:kahrs-homepage] https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html
                    Downloaded: 2017-03-21 10:23

* Benchmarks
** Procedure
   We did two benchmarks to . The first benchmarks is the sum of a list. The
   second is sorting a list using a red-black tree and then summing it.

   For the red-black tree benchmark we have the following variants:
  * An Agda implementation compiled to Haskell using MAlonzo and to Malfunction
    using our backend.
  * A Haskell implementation.
  * A Haskell implementation using nested higher-order types
  * A Haskell implementation using existential types

  We also varied; 1) the length of the list and 2) the sortedness of the lists
  (sorted, reversed sorted, randomized). For the randomized lists we used the
  Blum Blum Shub pseudo-random number generation algorithm to generate
  (pseudo-)randmoized lists. The advantage of using this approach is the the
  results are deterministic, and therefore reproducible, and it is fairly easy
  to compute.

  We used the C Preprocessor to handle these different variants. So the programs
  do not do any input. All tests procede by sorting a list using
  =toList . fromList=, so converting to and from a red/black tree and then summing the
  resulting list. Profiling output from the Haskell-implementations show us that
  the largest cost-center (around 95%) is the generation of the tree. We do not
  have access to similar resources for the Agda implementations but we don't
  expect that the picture should be any different here.

** Results
*** Summing sorted lists
    [[./img/sum_sorted.pdf]]

    Generation of sorted lists:
    #+BEGIN_SRC haskell
      -- Non-tail recursive
      fromTo, fromTo' :: Int -> [Int]
        fromTo n = f n
          where
            f 0 = []
            f x = n - x + 1 : f (x - 1)

        -- Tail recursive
        fromTo' = f []
          where
            f xs 0 = xs
            f !xs x = f (x : xs) (x - 1)
    #+END_SRC
    For the generation of random list we use

    We see that non-tail recursive Haskell version is
    greatly optimized and it uses constant memory, consequently, is a lot faster than all
    the other versions. Both MAlonzo versions and the tail recursive Haskell
    version perform very similarly. Malfunction version is faster than MAlonzo.
    The Malfunction version is better that the MAlonzo backend but not as fast
    as the best non-tail recursive Haskell version.

    We also did a benchmark with reversed lists, the results look similar.

*** Tree-sorting and summing random lists
    #+CAPTION: Treesorting and summing a random list.
    #+ATTR_LATEX: :float
    [[./img/treesort_rand_all.pdf]]

     #+BEGIN_SRC haskell
     fromList, fromList' :: Ord a => [a] -> Tree a
     fromList = foldr insert empty
     fromList' = foldl' (flip insert) empty
     #+END_SRC
     #+BEGIN_EXAMPLE
                      inherited
   COST CENTRE        %time  %alloc
     ...
    fromList          94.9   91.0
     insert           91.6   80.9
     ...
     #+END_EXAMPLE

    We can see that the strict- and lazy Malfunction-versions have a very similar
    performance[fn::In fact, we know that they compile to the same program.
    Discussion section.], and we can further see that they perform
    similarly to the MAlonzo version.

    Quite surprisingly the Haskell versions all perform worse than the Agda
    implementations. We suspect this may be an issue with how the red/black
    algorithm was implemented.


    #+CAPTION: Treesorting and summing a long sorted list.
    #+ATTR_LATEX: :float
    [[./img/treesort_sorted_best.pdf]]
    In this benchmark the Malfunction backend performs about twice as fast as the MAlonzo backend.

    #+CAPTION: Treesorting and summing a long random list.
    #+ATTR_LATEX: :float
    [[./img/treesort_rand_best.pdf]]
    We also see that the Malfunction backend performs about ten times faster than the MAlonzo
    backend.
* Discussion
  # TODO: clarify
  The difference in implementation of the lazy- and strict-versions of the
  red/black-algorithm in Agda boil down to how =fromList= is implemented:

  #+BEGIN_EXAMPLE
  fromList = foldl! (flip insert) (mkT leaf)
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  fromList = foldl  (flip insert) empty
  fromList = foldr insert empty
  #+END_EXAMPLE

  So in this example writing a more strict and better performing immplementation
  using the Haskell backend requires a trivial change. Of course identifying
  where to use and where not to use strictness in a lazy setting may not be as
  easy as in this case.

  Compiling to a language with strict call-semantics means that "adding
  strictness" should have close to no impact on the resulting program, and
  indeed we implemented =seq= like so:

  #+BEGIN_EXAMPLE
  seq _ a = a
  #+END_EXAMPLE

  Strictness forced us to reformulate parts of the program to avoid a
  stack-overflow when constructing the red-black tree. Similarly we explicitly
  added a strict fold to gain a performance boost when using the MAlonzo
  backend. This highlights that there are different things to be aware of
  depending on which call-semantics you are writing a program for. We also
  conclude that the example illustrates the benefit of using strict evaluation
  but also that it may be easy to achieve similar effects using the MAlonzo
  backend.

  As we've already mentioned our compiler suffers from some limitations due to
  lack of support for mapping primitives to the host-languages. This means that
  there are features that we've not been able to compare but at least in the
  case of the red/black-algorithm we've shown that compiling using the
  Malfunction backend generates roughly twice as fast a program than using the
  MAlonzo backend.
  # TODO: revise 'twice as fast' claim

* Perspectives
  # What further work could be done?
  Further effort should be put into figuring out why the Haskell implementations
  are running so slowly. Comparing the results with Haskell reference
  implementations is problematic because they are entirely different programs.
  And it is very surprising that an implementation of a program that compiles to
  Haskell is able to outperform a program written directly in Haskell.

  Further work should be put into figuring out why we get a stack-overflow when
  using =foldr=.

  To be able to more confidently compare the efficiency of the executables
  produced by our compiler benchmark of more algorithms would be useful.

  It would be desirable to have support for =COMPILE= and =FOREGIN= pragma.

  The compiler should ideally be merged into the Agda codebase.

  Adding optimizations to the compiler would also be beneficial.

* Conclusion
  We have presented our work with implementing a new backend for the Agda
  compiler targeting Malfunction a backend for the OCaml programming language.
  We've discussed some of the limitations of this implementation. We've
  successfully used it to compile an implementation of the red/black
  tree-sorting algorithm. We then performed benchmarks using this Agda
  implementation as well as three reference Haskell implementations. These
  benchmarks showed that our backend outperforms the other configurations for
  sorting randomized lists and ties with the MAlonzo backend for sorting already
  sorted lists. We also pointed out the fact that our comparison with the
  Haskell reference implementations is problematic since it is an entirely
  different implementation.
