Release notes for Agda version 2.6.2
====================================

Installation and infrastructure
-------------------------------

* Added support for GHC 8.10.1
  [Issue [#4242](https://github.com/agda/agda/issues/4242)] and GHC
  8.8.3 [Issue [#4476](https://github.com/agda/agda/issues/4476)].

Command-line interaction
------------------------

* In the previous release, Agda exited with either status 0 when the program
  type checks successfully, or status 1 when encountering any kind of error.
  Now Agda exits with status 42 for type errors, 71 for errors in the
  commandline arguments, and 154 for impossible errors. Exit status 1
  may be returned under other circumstances; for instance, an incomplete
  pattern matching, or an error generated by the Haskell runtime.
  See PR [#4540](https://github.com/agda/agda/pull/4540).

Pragmas and options
-------------------

* New options `--qualified-instances` (default) and
  `--no-qualified-instances`. When `--no-qualified-instances` is
  enabled, Agda will only consider candidates for instance search that
  are in scope under an unqualified name (see
  [#4522](https://github.com/agda/agda/pull/4522)).

* New option `--call-by-name` turns off call-by-need evaluation at type
  checking time.

* New option `--highlight-occurrences` (off by default) enables the HTML
  backend to include a JavaScript file that highlights all occurrences of
  the mouse-hovered symbol (see
  [#4535](https://github.com/agda/agda/pull/4535)).

* New option `--no-import-sorts` disables the implicit `open
  import Agda.Primitive using (Set; Prop)` at the top of each file
  (see below).

* New option `--auto-inline` turns on automatic compile-time inlining of simple
  functions. This was previously enabled by default.

* New option `--local-confluence-check` to restore the old behaviour
  of the `--confluence-check` flag (see below for the new behaviour).

* New primitive `primStringFromListInjective` internalising the fact that
  `primStringFromList` is an injective function. It is bound in
  `Agda.Builtin.String.Properties`.

* New option `--allow-exec` enables the use of system calls during type checking
  using the `AGDATCMEXECTC` builtin.

Language
--------

* Inductive records without η-equality no longer support both matching
  on the record constructor and construction of record elements by
  copattern matching.  It has been discovered that the combination of
  both leads to loss of subject reduction, i.e., reduction does not
  preserve typing.  See issue
  [#4560](https://github.com/agda/agda/issues/4560).

  η-equality for a record can be turned off manually with directive
  `no-eta-equality` or command-line option `--no-eta-equality`, but it
  is also automatically turned off for some recursive records.  For
  records without η, matching on the record constructor is now off by
  default and construction by copattern matching is on.  If you want
  the converse, you can add the new record directive `pattern`.

  Example with record pattern:
  ```agda
  record N : Set where
    inductive
    no-eta-equality
    pattern
    field out : Maybe N

  pred : N → Maybe N
  pred record{ out = m } = m
  ```
  Example with record constructor and use of `;` instead of newline:
  ```agda
  record N : Set where
    inductive; no-eta-equality
    pattern; constructor inn
    field out : Maybe N

  pred : N → Maybe N
  pred (inn m) = m
  ```

* `Set` and `Prop` are no longer keywords but are now primitives
  defined in the module `Agda.Primitive`. They can be renamed when
  importing this module, for example:

  ```agda
  open import Agda.Primitive renaming (Set to Type)

  test : Type₁
  test = Type
  ```

  To preserve backwards compatibility, each top-level Agda module now
  starts with an implicit statement:

  ```agda
  open import Agda.Primitive using (Set; Prop)
  ```

  This implicit import can be disabled with the
  `--no-import-sorts` flag.

* Agda now has support for sorts `Setωᵢ` (alternative syntax: `Setωi`)
  for natural numbers `i`, where `Setω₀ = Setω`. These sorts form a
  second hierarchy `Setωᵢ : Setωᵢ₊₁` similar to the standard hierarchy
  of `Setᵢ`, but do not support universe polymorphism. It should not
  be necessary to refer to these sorts during normal usage of Agda,
  but they might be useful for defining reflection-based macros (see
  [#2119](https://github.com/agda/agda/issues/2119) and
  [#4585](https://github.com/agda/agda/issues/4585)).

* Changed the internal representation of literal strings: instead of using a
  linked list of characters (`String`), we are now using `Data.Text`. This
  should be a transparent change from the user's point of view: the backend
  was already packing these strings as text.

  Used this opportunity to introduce a `primStringUncons` primitive in
  `Agda.Builtin.String` (and to correspondingly add the `Agda.Builtin.Maybe`
  it needs).

* The option `--confluence-check` for rewrite rules has been given a
  new implementation that checks global confluence instead of local
  confluence. Concretely, it does so by enforcing two properties:

  1. For any two left-hand sides of the rewrite rules that overlap
     (either at the root position or at a subterm), the most general
     unifier of the two left-hand sides is again a left-hand side of a
     rewrite rule. For example, if there are two rules @suc m + n =
     suc (m + n)@ and @m + suc n = suc (m + n)@, then there should
     also be a rule @suc m + suc n = suc (suc (m + n))@.

  2. Each rewrite rule should satisfy the *triangle property*: For any
     rewrite rule @u = w@ and any single-step parallel unfolding @u =>
     v@, we should have another single-step parallel unfolding @v =>
     w@.

  The previous behaviour of the confluence checker that only ensures
  local confluence can be restored by using the
  `--local-confluence-check` flag.

* Binary integer literals with prefix `0b` (for instance, `0b11001001`) are now
  supported.

Builtins
--------

- Primitive operations for floating-point numbers changed. The equalities now
  follow IEEE 754 equality, after unifying all NaNs. Primitive inequality was
  added:
  ```agda
  primFloatEquality   : Float -> Float -> Bool -- from primFloatNumericEquality
  primFloatLess       : Float -> Float -> Bool -- from primFloatNumericLess
  primFloatInequality : Float -> Float -> Bool -- new
  ```
  The “numeric” relations are now deprecated.

  There are several new predicates on floating-point numbers:
  ```agda
  primFloatIsInfinite     : Float -> Bool -- new
  primFloatIsNaN          : Float -> Bool -- new
  primFloatIsSafeInteger  : Float -> Bool -- new
  ```
  The primFloatIsSafeInteger function determines whether the value is a number
  that is a safe integer, i.e., is within the range where the arithmetic
  operations do not lose precision.

  The operations for conversion to integers (primRound, primFloor, and
  primCeiling) were renamed for consistency, and return a value of type `Maybe
  Int`, returning `nothing` for NaN and the infinities:
  ```agda
  primFloatRound   : Float → Maybe Int -- from primRound
  primFloatFloor   : Float → Maybe Int -- from primFloor
  primFloatCeiling : Float → Maybe Int -- from primCeiling
  ```

  There are several new conversions:
  ```agda
  primIntToFloat    : Int -> Float               -- new
  primFloatToRatio  : Float -> (Int × Nat)       -- new
  primRatioToFloat  : Int -> Nat -> Float        -- new
  primFloatDecode   : Float -> Maybe (Int × Int) -- new
  primFloatEncode   : Int -> Int -> Maybe Float  -- new
  ```
  The `primFloatDecode` function decodes a floating-point number f to a mantissa
  and exponent, such that `f = mantissa * 2 ^ exponent`, normalised such that
  the mantissa is the smallest possible number. The `primFloatEncode` function
  encodes a pair of a mantissa and exponent to a floating-point number.

  There are several new operations:
  ```agda
  primFloatPow        : Float -> Float -> Float -- new
  primFloatATan2      : Float -> Float -> Float -- from primATan2
  primFloatSinh       : Float -> Float          -- new
  primFloatCosh       : Float -> Float          -- new
  primFloatTanh       : Float -> Float          -- new
  primFloatASinh      : Float -> Float          -- new
  primFloatACosh      : Float -> Float          -- new
  primFloatATanh      : Float -> Float          -- new
  ```
  Furthermore, the following operations were renamed for consistency:
  ```agda
  primFloatExp        : Float -> Float          -- from primExp
  primFloatSin        : Float -> Float          -- from primSin
  primFloatLog        : Float -> Float          -- from primLog
  primFloatCos        : Float -> Float          -- from primCos
  primFloatTan        : Float -> Float          -- from primTan
  primFloatASin       : Float -> Float          -- from primASin
  primFloatACos       : Float -> Float          -- from primACos
  primFloatATan       : Float -> Float          -- from primATan
  ```

  All of these operations are implemented on the JavaScript backend.

Reflection
----------

- New operation in `TC` monad, similar to `quoteTC` but operating on types in `Setω`
  ```agda
  quoteωTC : ∀ {A : Setω} → A → TC Term
  ```
- `typeError` and `debugPrint` no longer inserts spaces around `termErr` and
  `nameErr` parts. They also do a better job of respecting line breaks in
  `strErr` parts.

- The representation of reflected patterns and clauses has
  changed. Each clause now includes a telescope with the names and
  types of the pattern variables.

  ```agda
  data Clause where
    clause        : (tel : List (Σ String λ _ → Arg Type)) (ps : List (Arg Pattern)) (t : Term) → Clause
    absurd-clause : (tel : List (Σ String λ _ → Arg Type)) (ps : List (Arg Pattern)) → Clause
  ```

  These telescopes provide additional information on the types of
  pattern variables that was previously hard to reconstruct (see
  [#2151](https://github.com/agda/agda/issues/2151)). When unquoting a
  clause, the types in the clause telescope are currently ignored (but
  this is subject to change in the future).

  Two constructors of the `Pattern` datatype were also changed:
  pattern variables now refer to a de Bruijn index (relative to the
  clause telescope) rather than a string, and dot patterns now include
  the actual dotted term.

  ```agda
  data Pattern where
    con    : (c : Name) (ps : List (Arg Pattern)) → Pattern
    dot    : (t : Term)    → Pattern   -- previously:   dot : Pattern
    var    : (x : Nat)     → Pattern   -- previously:   var : (x : String) → Pattern
    lit    : (l : Literal) → Pattern
    proj   : (f : Name)    → Pattern
    absurd : Pattern
  ```

  It is likely that this change to the reflected syntax requires you
  to update reflection code written for previous versions of
  Agda. Here are some tips for updating your code:

  * When quoting a clause, you can recover the name of a pattern
    variable by looking up the given index in the clause
    telescope. The contents of dot patterns can safely be ignored
    (unless you have a use for them).

  * When creating a new clause for unquoting, you need to create a
    telescope for the types of the pattern variables. To get back the
    old behaviour of Agda, it is sufficient to set all the types of
    the pattern variables to `unknown`. So you can construct the
    telescope by listing the names of all pattern variables together
    with their `ArgInfo`. Meanwhile, the pattern variables should be
    numbered in order to update them to the new representation. As for
    the telescope types, the contents of a `dot` pattern can safely be
    set to `unknown`.

- New operation in `TC` monad, `execTC`, which calls an external executable
  ```agda
  execTC : (exe : String) (args : List String) (stdIn : String)
         → TC (Σ Nat (λ _ → Σ String (λ _ → String)))
  ```
  The `execTC` builtin takes three arguments: the basename of the executable (e.g., `"echo"`), a list of arguments, and the contents of the standard input. It returns a triple, consisting of the exit code (as a natural number), the contents of the standard output, and the contents of the standard error.

  The builtin is only available when `--allow-exec` is passed. (Note that `--allow-exec` is incompatible with ``--safe``.) To make an executable available to Agda, add the absolute path on a new line in `~/.agda/executables`.


Emacs mode
----------

* New command prefix `C-u C-u C-u` for weak-head normalization. For instance,
  given

  ```agda
  downFrom : Nat → List Nat
  downFrom 0 = []
  downFrom (suc n) = n ∷ downFrom n
  ```

  `C-u C-u C-u C-c C-n downFrom 5` returns `4 ∷ downFrom 4`.

* New keyboard shortcut `C-c C-x C-i` for toggling display of irrelevant arguments.


JS backend
----------

- Smaller local variable names in the generated JS code.

  Previously: `x0`, `x1`, `x2`, ...

  Now: `a`, `b`, `c`, ..., `z`, `a0`, `b0`, ..., `z0`, `a1`, `b1`, ...

- Improved indentation of generated JS code.

- More compact rendering of generated JS functions.

  Previously:
  ```js
  exports["N"]["suc"] = function (x0) {
      return function (x1) {
        return x1["suc"](x0);
      };
    };
  ```

  Now:
  ```js
  exports["N"]["suc"] = a => b => b["suc"](a);
  ```

- Irrelevant arguments are now erased in the generated JS code.

  Example Agda code:
  ```agda
  flip : {A B C : Set} -> (B -> A -> C) -> A -> B -> C
  flip f a b = f b a
  ```

  Previously generated JS code:
  ```js
  exports["flip"] = function (x0) {
      return function (x1) {
        return function (x2) {
          return function (x3) {
            return function (x4) {
              return function (x5) {
                return x3(x5)(x4);
              };
            };
          };
        };
      };
    };
  ```

  JS code generated now:
  ```js
  exports["flip"] = a => b => c => a(c)(b);
  ```

- Record fields are not stored separately (the fields are stored only in the constructor)
  in the generated JS code.

  Example Agda code:
  ```agda
  record Sigma (A : Set) (B : A -> Set) : Set where
    field
      fst : A
      snd : B fst
  ```

  Previously generated JS code (look at the `"fst"` and `"snd"` fields in the
  return value of `exports["Sigma"]["record"]`:
  ```js
  exports["Sigma"] = {};
  exports["Sigma"]["fst"] = function (x0) {
      return x0["record"]({
        "record": function (x1, x2) {
          return x1;
        }
      });
    };
  exports["Sigma"]["snd"] = function (x0) {
      return x0["record"]({
        "record": function (x1, x2) {
          return x2;
        }
      });
    };
  exports["Sigma"]["record"] = function (x0) {
      return function (x1) {
        return {
          "fst": x0,
          "record": function (x2) {
            return x2["record"](x0, x1);
          },
          "snd": x1
        };
      };
    };
  ```

  JS code generated now:
  ```js
  exports["Sigma"] = {};
  exports["Sigma"]["fst"] = a => a["record"]({"record": (b,c) => b});
  exports["Sigma"]["snd"] = a => a["record"]({"record": (b,c) => c});
  exports["Sigma"]["record"] = a => b => ({"record": c => c["record"](a,b)});
  ```

- `--js-optimize` flag has been added to the `agda` compiler.

  With `--js-optimize`, `agda` does not wrap records in JS objects.

  Example Agda code:
  ```agda
  record Sigma (A : Set) (B : A -> Set) : Set where
    field
      fst : A
      snd : B fst
  ```

  JS code generated without the `--js-optimize` flag:
  ```js
  exports["Sigma"] = {};
  exports["Sigma"]["fst"] = a => a["record"]({"record": (b,c) => b});
  exports["Sigma"]["snd"] = a => a["record"]({"record": (b,c) => c});
  exports["Sigma"]["record"] = a => b => ({"record": c => c["record"](a,b)});
  ```

  JS code generated with the `--js-optimize` flag:
  ```js
  exports["Sigma"] = {};
  exports["Sigma"]["fst"] = a => a((b,c) => b);
  exports["Sigma"]["snd"] = a => a((b,c) => c);
  exports["Sigma"]["record"] = a => b => c => c(a,b);
  ```

  With `--js-optimize`, `agda` uses JS arrays instead of JS objects.
  This is possible because constructor names are not relevant during the evaluation.

  Example Agda code:
  ```agda
  data Bool : Set where
    false : Bool
    true  : Bool

  not : Bool -> Bool
  not false = true
  not true  = false
  ```

  JS code generated without the `--js-optimize` flag:
  ```js
  exports["Bool"] = {};
  exports["Bool"]["false"] = a => a["false"]();
  exports["Bool"]["true"] = a => a["true"]();
  exports["not"] = a => a({
      "false": () => exports["Bool"]["true"],
      "true": () => exports["Bool"]["false"]
    });
  ```

  JS code generated with the `--js-optimize` flag:
  ```js
  exports["Bool"] = {};
  exports["Bool"]["false"] = a => a[0/* false */]();
  exports["Bool"]["true"] = a => a[1/* true */]();
  exports["not"] = a => a([
      /* false */() => exports["Bool"]["true"],
      /* true */() => exports["Bool"]["false"]
    ]);
  ```

  Note that comments are added to generated JS code to help human readers.

  Erased branches are replaced by `null` in the generated array.
  If more than the half of branches are erased, the array is compressed to
  be a object like `{3: ..., 13: ...}`.

- `--js-minify` flag has been added to the `agda` compiler.

  With `--js-minify`, `agda` discards comments and whitespace in the generated JS code.
