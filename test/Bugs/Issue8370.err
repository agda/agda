AGDA_FAILURE

ret > ExitFailure 42
out > Issue8370.agda:21.1-6: error: [UnequalTerms]
out > The terms
out >   transp
out >   (λ j →
out >      transp (λ i → Set) (primINeg (primIMax (primINeg j) (primINeg i1)))
out >      (primPOr i0 (primIMax (primINeg i1) i1) (λ .o → back Id.refl i1)
out >       (primPOr (primINeg i1) i1 (λ .o → Canon)
out >        (λ .o →
out >           R.getType
out >           (primComp (λ i → R)
out >            (λ i →
out >               primPOr i0
out >               (primIMax
out >                (primINeg
out >                 (primINeg (primINeg (primIMax (primINeg j) (primINeg i1)))))
out >                (primIMax
out >                 (primINeg (primINeg (primIMax (primINeg j) (primINeg i1)))) i0))
out >               (λ .o₁ → mkR Canon)
out >               (primPOr
out >                (primINeg
out >                 (primINeg (primINeg (primIMax (primINeg j) (primINeg i1)))))
out >                (primIMax
out >                 (primINeg (primINeg (primIMax (primINeg j) (primINeg i1)))) i0)
out >                (λ .o₁ → mkR Canon) (λ .o₁ → mkR Canon)))
out >            (mkR Canon))))
out >       _))
out >   i0
out >   (Agda.Builtin.Cubical.HCompU.b'
out >    (λ i →
out >       transp (λ i₁ → Set) (primINeg i)
out >       (primPOr i0 (primIMax (primINeg i1) i1) (λ .o → back Id.refl i1)
out >        (primPOr (primINeg i1) i1 (λ .o → Canon)
out >         (λ .o →
out >            R.getType
out >            (primComp (λ i₁ → R)
out >             (λ i₁ →
out >                primPOr i0
out >                (primIMax (primINeg (primINeg (primINeg i)))
out >                 (primIMax (primINeg (primINeg i)) i0))
out >                (λ .o₁ → mkR Canon)
out >                (primPOr (primINeg (primINeg (primINeg i)))
out >                 (primIMax (primINeg (primINeg i)) i0) (λ .o₁ → mkR Canon)
out >                 (λ .o₁ → mkR Canon)))
out >             (mkR Canon))))
out >        _))
out >    i0
out >    (primPOr i0
out >     (Agda.Builtin.Cubical.HCompU.primFaceForall
out >      (λ i → primIMax (primINeg i) i))
out >     (λ .o → canon)
out >     (λ .o →
out >        transp
out >        (λ .j →
out >           transp (λ i → Set) i1
out >           (primPOr i0 (primIMax (primINeg (primIMin i1 j)) (primIMin i1 j))
out >            (λ .o₁ → back Id.refl (primIMin i1 j))
out >            (primPOr (primINeg (primIMin i1 j)) (primIMin i1 j) (λ .o₁ → Canon)
out >             (λ .o₁ →
out >                R.getType
out >                (primComp (λ i → R)
out >                 (λ i →
out >                    primPOr i0
out >                    (primIMax (primINeg (primINeg i1)) (primIMax (primINeg i1) i0))
out >                    (λ .o₂ → mkR Canon)
out >                    (primPOr (primINeg (primINeg i1)) (primIMax (primINeg i1) i0)
out >                     (λ .o₂ → mkR Canon) (λ .o₂ → mkR Canon)))
out >                 (mkR Canon))))
out >            _))
out >        (primIMax i0 (primINeg i1)) canon))
out >    (Agda.Builtin.Cubical.Sub.inS
out >     (primHComp
out >      (λ i →
out >         primPOr
out >         (primIMax i0
out >          (Agda.Builtin.Cubical.HCompU.primFaceForall
out >           (λ i₁ → primIMax (primINeg i₁) i₁)))
out >         (primINeg
out >          (primIMax i0
out >           (Agda.Builtin.Cubical.HCompU.primFaceForall
out >            (λ i₁ → primIMax (primINeg i₁) i₁))))
out >         (λ .o →
out >            transp
out >            (λ i₁ → transp (λ i₂ → Set) i0 (back Id.refl (primIMax i₁ i))) i
out >            (primPOr i0
out >             (Agda.Builtin.Cubical.HCompU.primFaceForall
out >              (λ i₁ → primIMax (primINeg i₁) i₁))
out >             (λ .o₁ → Agda.Builtin.Cubical.HCompU.prim^unglueU canon)
out >             (λ .o₁ →
out >                transp
out >                (λ i₁ →
out >                   transp (λ i₂ → Set) (primINeg i₁)
out >                   (primPOr i0 (primIMax (primINeg i) i) (λ .o₂ → back Id.refl i)
out >                    (primPOr (primINeg i) i (λ .o₂ → Canon)
out >                     (λ .o₂ →
out >                        R.getType
out >                        (primComp (λ i₂ → R)
out >                         (λ i₂ →
out >                            primPOr i0
out >                            (primIMax (primINeg (primINeg (primINeg i₁)))
out >                             (primIMax (primINeg (primINeg i₁)) i0))
out >                            (λ .o₃ → mkR Canon)
out >                            (primPOr (primINeg (primINeg (primINeg i₁)))
out >                             (primIMax (primINeg (primINeg i₁)) i0) (λ .o₃ → mkR Canon)
out >                             (λ .o₃ → mkR Canon)))
out >                         (mkR Canon))))
out >                    _))
out >                i0
out >                (transp
out >                 (λ .j →
out >                    transp (λ i₁ → Set) i1
out >                    (primPOr i0 (primIMax (primINeg (primIMin i j)) (primIMin i j))
out >                     (λ .o₂ → back Id.refl (primIMin i j))
out >                     (primPOr (primINeg (primIMin i j)) (primIMin i j) (λ .o₂ → Canon)
out >                      (λ .o₂ →
out >                         R.getType
out >                         (primComp (λ i₁ → R)
out >                          (λ i₁ →
out >                             primPOr i0
out >                             (primIMax (primINeg (primINeg i1)) (primIMax (primINeg i1) i0))
out >                             (λ .o₃ → mkR Canon)
out >                             (primPOr (primINeg (primINeg i1)) (primIMax (primINeg i1) i0)
out >                              (λ .o₃ → mkR Canon) (λ .o₃ → mkR Canon)))
out >                          (mkR Canon))))
out >                     _))
out >                 (primIMax i0 (primINeg i)) canon))
out >             _))
out >         (λ .o →
out >            transp
out >            (λ i₁ → transp (λ i₂ → Set) i0 (back Id.refl (primIMax i₁ i0))) i0
out >            (Agda.Builtin.Cubical.HCompU.prim^unglueU canon)))
out >      (transp
out >       (λ i → transp (λ i₁ → Set) i0 (back Id.refl (primIMax i i0))) i0
out >       (Agda.Builtin.Cubical.HCompU.prim^unglueU canon)))))
out > and
out >   canon
out > are not equal at type Canon
out > when checking that a clause of hmm has the correct boundary.
out >
out > Specifically, the terms
out >   Agda.Builtin.Cubical.HCompU.transpProof
out >   (λ i →
out >      R.getType
out >      (primComp (λ i₁ → R)
out >       (λ i₁ →
out >          primPOr (primINeg i) i (λ .o → mkR Canon) (λ .o → mkR Canon))
out >       (mkR Canon)))
out >   i0
out >   (λ .o →
out >      transp
out >      (λ .j → primPOr (primINeg j) j (λ .o₁ → Canon) (λ .o₁ → Canon) _)
out >      i0 canon)
out >   (Agda.Builtin.Cubical.Sub.inS canon) .Agda.Builtin.Sigma.Σ.fst
out > and
out >   canon
out > must be equal, since hmm i0 could reduce to either.
out >
