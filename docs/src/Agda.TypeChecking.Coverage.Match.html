<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span>
</span><span id="line-2"></span><span class="annot"><span class="hs-comment">{-| Given

    1. the function clauses @cs@
    2. the patterns @ps@ of the split clause

we want to compute a variable index (in the split clause) to split on next.

The matcher here checks whether the split clause is covered by one of
the given clauses @cs@ or whether further splitting is needed (and
when yes, where).
-}</span></span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html"><span class="hs-identifier">Agda.TypeChecking.Coverage.Match</span></a></span><span>
</span><span id="line-15"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier">Match</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#match"><span class="hs-identifier">match</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchClause"><span class="hs-identifier">matchClause</span></a></span><span>
</span><span id="line-16"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier">BlockingVar</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier">BlockingVars</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier">BlockedOnResult</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-17"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#setBlockingVarOverlap"><span class="hs-identifier">setBlockingVarOverlap</span></a></span><span>
</span><span id="line-18"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#ApplyOrIApply"><span class="hs-identifier">ApplyOrIApply</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-19"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">null</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.DList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">DList</span></span><span class="hs-special">)</span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">toList</span></span><span class="hs-special">)</span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">List</span></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">fromMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-27"></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html"><span class="hs-identifier">Agda.Syntax.Common</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html"><span class="hs-identifier">Agda.Syntax.Internal</span></a></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Literal.html"><span class="hs-identifier">Agda.Syntax.Literal</span></a></span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.html"><span class="hs-identifier">Agda.TypeChecking.Monad</span></a></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html"><span class="hs-identifier">Agda.TypeChecking.Coverage.SplitPattern</span></a></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Pretty.html"><span class="hs-identifier">Agda.TypeChecking.Pretty</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Pretty.html#PrettyTCM"><span class="hs-identifier">PrettyTCM</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Records.html"><span class="hs-identifier">Agda.TypeChecking.Records</span></a></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Reduce.html"><span class="hs-identifier">Agda.TypeChecking.Reduce</span></a></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Substitute.html"><span class="hs-identifier">Agda.TypeChecking.Substitute</span></a></span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Null.html"><span class="hs-identifier">Agda.Utils.Null</span></a></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.Pretty.html"><span class="hs-identifier">Agda.Syntax.Common.Pretty</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.Pretty.html#Pretty"><span class="hs-identifier">Pretty</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">text</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;+&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">cat</span></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.Pretty.html#prettyList_"><span class="hs-identifier">prettyList_</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Monad.html"><span class="hs-identifier">Agda.Utils.Monad</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Singleton.html"><span class="hs-identifier">Agda.Utils.Singleton</span></a></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Impossible.html"><span class="hs-identifier">Agda.Utils.Impossible</span></a></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Position.html"><span class="hs-identifier">Agda.Syntax.Position</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Position.html#KillRange"><span class="hs-identifier">KillRange</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Position.html#killRange"><span class="hs-identifier">killRange</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Position.html#killRangeN"><span class="hs-identifier">killRangeN</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span class="hs-comment">-- | If matching is inconclusive (@Block@) we want to know which</span><span>
</span><span id="line-48"></span><span class="hs-comment">--   variables or projections are blocking the match.</span><span>
</span><span id="line-49"></span><span class="hs-keyword">data</span><span> </span><span id="Match"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span id="local-6989586621682025908"><span class="annot"><a href="#local-6989586621682025908"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Yes"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621682025908"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ Matches unconditionally.</span></span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="No"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Definitely does not match.</span></span><span>
</span><span id="line-52"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Block"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span></span><span>
</span><span id="line-53"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="blockedOnResult"><span class="annot"><span class="annottext">forall a. Match a -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnResult"><span class="hs-identifier hs-var hs-var">blockedOnResult</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span>
</span><span id="line-54"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ @BlockedOnProj o@ if the clause has a result split.</span></span><span>
</span><span id="line-55"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="blockedOnVars"><span class="annot"><span class="annottext">forall a. Match a -&gt; BlockingVars
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnVars"><span class="hs-identifier hs-var hs-var">blockedOnVars</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier hs-type">BlockingVars</span></a></span><span>
</span><span id="line-56"></span><span>      </span><span class="hs-comment">-- ^ @BlockingVar i cs ls o@ means variable @i@ is blocked on</span><span>
</span><span id="line-57"></span><span>      </span><span class="hs-comment">-- constructors @cs@ and literals @ls@.</span><span>
</span><span id="line-58"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-59"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621682026135"><span id="local-6989586621682026137"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b)
-&gt; (forall a b. a -&gt; Match b -&gt; Match a) -&gt; Functor Match
forall a b. a -&gt; Match b -&gt; Match a
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
fmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
$c&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="annot"><span class="hs-comment">-- | Missing elimination blocking a match.</span></span><span>
</span><span id="line-62"></span><span class="hs-keyword">data</span><span> </span><span id="BlockedOnResult"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-var">BlockedOnResult</span></a></span></span><span>
</span><span id="line-63"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="BlockedOnProj"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-var">BlockedOnProj</span></a></span></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Blocked on unsplit projection.</span></span><span>
</span><span id="line-64"></span><span>     </span><span class="hs-special">{</span><span> </span><span id="blockedOnResultOverlap"><span class="annot"><span class="annottext">BlockedOnResult -&gt; Bool
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnResultOverlap"><span class="hs-identifier hs-var hs-var">blockedOnResultOverlap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-65"></span><span>       </span><span class="hs-comment">-- ^ True if there are also matching clauses without an unsplit</span><span>
</span><span id="line-66"></span><span>       </span><span class="hs-comment">-- copattern.</span><span>
</span><span id="line-67"></span><span>     </span><span class="hs-special">}</span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BlockedOnApply"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnApply"><span class="hs-identifier hs-var">BlockedOnApply</span></a></span></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Blocked on unintroduced argument.</span></span><span>
</span><span id="line-69"></span><span>     </span><span class="hs-special">{</span><span> </span><span id="blockedOnResultIApply"><span class="annot"><span class="annottext">BlockedOnResult -&gt; ApplyOrIApply
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnResultIApply"><span class="hs-identifier hs-var hs-var">blockedOnResultIApply</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#ApplyOrIApply"><span class="hs-identifier hs-type">ApplyOrIApply</span></a></span><span>
</span><span id="line-70"></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Is the unintroduced argument an 'IApply' pattern?</span></span><span>
</span><span id="line-71"></span><span>     </span><span class="hs-special">}</span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NotBlockedOnResult"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-var">NotBlockedOnResult</span></a></span></span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span class="hs-keyword">data</span><span> </span><span id="ApplyOrIApply"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#ApplyOrIApply"><span class="hs-identifier hs-var">ApplyOrIApply</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="IsApply"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#IsApply"><span class="hs-identifier hs-var">IsApply</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="IsIApply"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#IsIApply"><span class="hs-identifier hs-var">IsIApply</span></a></span></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span class="annot"><span class="hs-comment">-- | Variable blocking a match.</span></span><span>
</span><span id="line-77"></span><span class="hs-keyword">data</span><span> </span><span id="BlockingVar"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-var">BlockingVar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="BlockingVar"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-var">BlockingVar</span></a></span></span><span>
</span><span id="line-78"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="blockingVarNo"><span class="annot"><span class="annottext">BlockingVar -&gt; Nat
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockingVarNo"><span class="hs-identifier hs-var hs-var">blockingVarNo</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span>
</span><span id="line-79"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ De Bruijn index of variable blocking the match.</span></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="blockingVarCons"><span class="annot"><span class="annottext">BlockingVar -&gt; [ConHead]
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockingVarCons"><span class="hs-identifier hs-var hs-var">blockingVarCons</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#ConHead"><span class="hs-identifier hs-type">ConHead</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-81"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Constructors in this position.</span></span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="blockingVarLits"><span class="annot"><span class="annottext">BlockingVar -&gt; [Literal]
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockingVarLits"><span class="hs-identifier hs-var hs-var">blockingVarLits</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Literal.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-83"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Literals in this position.</span></span><span>
</span><span id="line-84"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="blockingVarOverlap"><span class="annot"><span class="annottext">BlockingVar -&gt; Bool
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockingVarOverlap"><span class="hs-identifier hs-var hs-var">blockingVarOverlap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-85"></span><span>    </span><span class="hs-comment">-- ^ True if at least one clause has a variable pattern in this</span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-comment">--   position.</span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="blockingVarLazy"><span class="annot"><span class="annottext">BlockingVar -&gt; Bool
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockingVarLazy"><span class="hs-identifier hs-var hs-var">blockingVarLazy</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-88"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ True if at least one clause has a lazy pattern in this position.</span></span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-special">}</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621682026156"><span id="local-6989586621682026170"><span id="local-6989586621682026174"><span class="annot"><span class="annottext">Nat -&gt; BlockingVar -&gt; ShowS
BlockingVars -&gt; ShowS
BlockingVar -&gt; String
(Nat -&gt; BlockingVar -&gt; ShowS)
-&gt; (BlockingVar -&gt; String)
-&gt; (BlockingVars -&gt; ShowS)
-&gt; Show BlockingVar
forall a.
(Nat -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Nat -&gt; BlockingVar -&gt; ShowS
showsPrec :: Nat -&gt; BlockingVar -&gt; ShowS
$cshow :: BlockingVar -&gt; String
show :: BlockingVar -&gt; String
$cshowList :: BlockingVars -&gt; ShowS
showList :: BlockingVars -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="hs-keyword">type</span><span> </span><span id="BlockingVars"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier hs-var">BlockingVars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-type">BlockingVar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span class="hs-comment">-- | Substitution of 'SplitPattern's for de Bruijn indices in covering</span><span>
</span><span id="line-94"></span><span class="hs-comment">--   clause to match 'SplitClause'.</span><span>
</span><span id="line-95"></span><span class="hs-keyword">type</span><span> </span><span id="SplitInstantiation"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#SplitInstantiation"><span class="hs-identifier hs-var">SplitInstantiation</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-identifier hs-type">SplitPattern</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#match"><span class="hs-pragma hs-type">match</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Clause"><span class="hs-pragma hs-type">Clause</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-pragma hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-pragma hs-type">SplitPattern</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-pragma hs-type">Match</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-pragma hs-type">Nat</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#SplitInstantiation"><span class="hs-pragma hs-type">SplitInstantiation</span></a></span><span class="hs-pragma">)</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- | Match the given patterns against a list of clauses.</span><span>
</span><span id="line-99"></span><span class="hs-comment">--</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- If successful, return the index of the covering clause.</span><span>
</span><span id="line-101"></span><span class="hs-comment">--</span><span>
</span><span id="line-102"></span><span id="local-6989586621682025926"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#match"><span class="hs-identifier hs-type">match</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025926"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-103"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Clause"><span class="hs-identifier hs-type">Clause</span></a></span><span class="hs-special">]</span><span>                           </span><span class="annot"><span class="hs-comment">-- ^ Search for clause that covers the patterns.</span></span><span>
</span><span id="line-104"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-identifier hs-type">SplitPattern</span></a></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">-- ^ Patterns of the current 'SplitClause'.</span></span><span>
</span><span id="line-105"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025926"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#SplitInstantiation"><span class="hs-identifier hs-type">SplitInstantiation</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-106"></span><span id="match"><span class="annot"><span class="annottext">match :: forall (m :: * -&gt; *).
PureTCM m =&gt;
[Clause]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (Nat, SplitInstantiation))
</span><a href="Agda.TypeChecking.Coverage.Match.html#match"><span class="hs-identifier hs-var hs-var">match</span></a></span></span><span> </span><span id="local-6989586621682026192"><span class="annot"><span class="annottext">[Clause]
</span><a href="#local-6989586621682026192"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621682026193"><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026193"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(m (Match (Nat, SplitInstantiation))
 -&gt; m (Match (Nat, SplitInstantiation))
 -&gt; m (Match (Nat, SplitInstantiation)))
-&gt; m (Match (Nat, SplitInstantiation))
-&gt; [m (Match (Nat, SplitInstantiation))]
-&gt; m (Match (Nat, SplitInstantiation))
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">m (Match (Nat, SplitInstantiation))
-&gt; m (Match (Nat, SplitInstantiation))
-&gt; m (Match (Nat, SplitInstantiation))
forall (m :: * -&gt; *) a.
Monad m =&gt;
m (Match a) -&gt; m (Match a) -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#choice"><span class="hs-identifier hs-var">choice</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match (Nat, SplitInstantiation)
-&gt; m (Match (Nat, SplitInstantiation))
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Match (Nat, SplitInstantiation)
forall a. Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([m (Match (Nat, SplitInstantiation))]
 -&gt; m (Match (Nat, SplitInstantiation)))
-&gt; [m (Match (Nat, SplitInstantiation))]
-&gt; m (Match (Nat, SplitInstantiation))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Nat -&gt; Clause -&gt; m (Match (Nat, SplitInstantiation)))
-&gt; [Nat] -&gt; [Clause] -&gt; [m (Match (Nat, SplitInstantiation))]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">Nat -&gt; Clause -&gt; m (Match (Nat, SplitInstantiation))
forall (m :: * -&gt; *).
PureTCM m =&gt;
Nat -&gt; Clause -&gt; m (Match (Nat, SplitInstantiation))
</span><a href="#local-6989586621682026197"><span class="hs-identifier hs-var">matchIt</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Nat
</span><span class="hs-number">0</span></span><span class="hs-glyph">..</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[Clause]
</span><a href="#local-6989586621682026192"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-107"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-108"></span><span>    </span><span id="local-6989586621682025949"><span class="annot"><a href="#local-6989586621682026197"><span class="hs-identifier hs-type">matchIt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025949"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-109"></span><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span>  </span><span class="hs-comment">-- Clause number.</span><span>
</span><span id="line-110"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Clause"><span class="hs-identifier hs-type">Clause</span></a></span><span>
</span><span id="line-111"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025949"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#SplitInstantiation"><span class="hs-identifier hs-type">SplitInstantiation</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-112"></span><span>    </span><span id="local-6989586621682026197"><span class="annot"><span class="annottext">matchIt :: forall (m :: * -&gt; *).
PureTCM m =&gt;
Nat -&gt; Clause -&gt; m (Match (Nat, SplitInstantiation))
</span><a href="#local-6989586621682026197"><span class="hs-identifier hs-var hs-var">matchIt</span></a></span></span><span> </span><span id="local-6989586621682026207"><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026207"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621682026208"><span class="annot"><span class="annottext">Clause
</span><a href="#local-6989586621682026208"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(DList (Nat, SplitPattern) -&gt; (Nat, SplitInstantiation))
-&gt; Match (DList (Nat, SplitPattern))
-&gt; Match (Nat, SplitInstantiation)
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621682026209"><span class="annot"><span class="annottext">DList (Nat, SplitPattern)
</span><a href="#local-6989586621682026209"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026207"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern) -&gt; SplitInstantiation
forall a. DList a -&gt; [a]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">toList</span></span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern)
</span><a href="#local-6989586621682026209"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Match (DList (Nat, SplitPattern))
 -&gt; Match (Nat, SplitInstantiation))
-&gt; m (Match (DList (Nat, SplitPattern)))
-&gt; m (Match (Nat, SplitInstantiation))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
-&gt; Clause -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *).
PureTCM m =&gt;
[NamedArg SplitPattern]
-&gt; Clause -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchClause"><span class="hs-identifier hs-var">matchClause</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026193"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">Clause
</span><a href="#local-6989586621682026208"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span class="hs-comment">-- | If matching succeeds, we return the instantiation of the clause pattern vector</span><span>
</span><span id="line-115"></span><span class="hs-comment">--   to obtain the split clause pattern vector.</span><span>
</span><span id="line-116"></span><span class="hs-keyword">type</span><span> </span><span id="MatchResult"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#MatchResult"><span class="hs-identifier hs-var">MatchResult</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-identifier hs-type">SplitPattern</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682026214"><span id="local-6989586621682026218"><span class="annot"><a href="Agda.Syntax.Common.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-type">BlockingVar</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-119"></span><span>  </span><span id="local-6989586621682026245"><span class="annot"><span class="annottext">pretty :: BlockingVar -&gt; Doc
</span><a href="#local-6989586621682026245"><span class="hs-identifier hs-var hs-var hs-var">pretty</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-type">BlockingVar</span></a></span><span> </span><span id="local-6989586621682026247"><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026247"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621682026248"><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026248"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621682026249"><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026249"><span class="hs-identifier hs-var">ls</span></a></span></span><span> </span><span id="local-6989586621682026250"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026250"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682026251"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026251"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Doc] -&gt; Doc
forall a. [Doc a] -&gt; Doc a
</span><span class="hs-identifier hs-var">cat</span></span><span>
</span><span id="line-120"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String -&gt; Doc
forall a. String -&gt; Doc a
</span><span class="hs-identifier hs-var">text</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;variable &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Nat -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026247"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-121"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[ConHead] -&gt; Bool
forall a. Null a =&gt; a -&gt; Bool
</span><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026248"><span class="hs-identifier hs-var">cs</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Doc
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Doc
</span><span class="hs-string">&quot; blocked on constructors&quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc -&gt; Doc -&gt; Doc
forall a. Doc a -&gt; Doc a -&gt; Doc a
</span><span class="hs-operator hs-var">&lt;+&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ConHead] -&gt; Doc
forall a. Pretty a =&gt; a -&gt; Doc
</span><a href="Agda.Syntax.Common.Pretty.html#pretty"><span class="hs-identifier hs-var">pretty</span></a></span><span> </span><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026248"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-122"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[Literal] -&gt; Bool
forall a. Null a =&gt; a -&gt; Bool
</span><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026249"><span class="hs-identifier hs-var">ls</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Doc
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Doc
</span><span class="hs-string">&quot; blocked on literals&quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc -&gt; Doc -&gt; Doc
forall a. Doc a -&gt; Doc a -&gt; Doc a
</span><span class="hs-operator hs-var">&lt;+&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Literal] -&gt; Doc
forall a. Pretty a =&gt; a -&gt; Doc
</span><a href="Agda.Syntax.Common.Pretty.html#pretty"><span class="hs-identifier hs-var">pretty</span></a></span><span> </span><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026249"><span class="hs-identifier hs-var">ls</span></a></span><span>
</span><span id="line-123"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026250"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Doc
</span><span class="hs-string">&quot; (overlapping)&quot;</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Doc
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-124"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026251"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Doc
</span><span class="hs-string">&quot; (lazy)&quot;</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Doc
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-125"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span id="local-6989586621682025977"><span id="local-6989586621682025978"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-type">yes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682025977"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025978"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025977"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025978"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-128"></span><span id="yes"><span class="annot"><span class="annottext">yes :: forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var hs-var">yes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; (a -&gt; Match a) -&gt; a -&gt; m (Match a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Match a
forall a. a -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span id="local-6989586621682025984"><span id="local-6989586621682025985"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-type">no</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682025984"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025984"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025985"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-131"></span><span id="no"><span class="annot"><span class="annottext">no :: forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var hs-var">no</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Match a
forall a. Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span id="local-6989586621682025988"><span id="local-6989586621682025990"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnConstructor"><span class="hs-identifier hs-type">blockedOnConstructor</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682025988"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConHead"><span class="hs-identifier hs-type">ConHead</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConPatternInfo"><span class="hs-identifier hs-type">ConPatternInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025988"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025990"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-134"></span><span id="blockedOnConstructor"><span class="annot"><span class="annottext">blockedOnConstructor :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Nat -&gt; ConHead -&gt; ConPatternInfo -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnConstructor"><span class="hs-identifier hs-var hs-var">blockedOnConstructor</span></a></span></span><span> </span><span id="local-6989586621682026265"><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026265"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621682026266"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026266"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682026267"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026267"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-var">NotBlockedOnResult</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Nat -&gt; [ConHead] -&gt; [Literal] -&gt; Bool -&gt; Bool -&gt; BlockingVar
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-var">BlockingVar</span></a></span><span> </span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026265"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026266"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; BlockingVar) -&gt; Bool -&gt; BlockingVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo -&gt; Bool
</span><a href="Agda.Syntax.Internal.html#conPLazy"><span class="hs-identifier hs-var">conPLazy</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026267"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span id="local-6989586621682025993"><span id="local-6989586621682025994"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnLiteral"><span class="hs-identifier hs-type">blockedOnLiteral</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682025993"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Nat"><span class="hs-identifier hs-type">Nat</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Literal.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025993"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025994"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-137"></span><span id="blockedOnLiteral"><span class="annot"><span class="annottext">blockedOnLiteral :: forall (m :: * -&gt; *) a. Monad m =&gt; Nat -&gt; Literal -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnLiteral"><span class="hs-identifier hs-var hs-var">blockedOnLiteral</span></a></span></span><span> </span><span id="local-6989586621682026272"><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026272"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621682026273"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026273"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-var">NotBlockedOnResult</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Nat -&gt; [ConHead] -&gt; [Literal] -&gt; Bool -&gt; Bool -&gt; BlockingVar
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-var">BlockingVar</span></a></span><span> </span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026272"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026273"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">]</span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span id="local-6989586621682026274"><span id="local-6989586621682026275"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnProjection"><span class="hs-identifier hs-type">blockedOnProjection</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682026274"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026274"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026275"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-140"></span><span id="blockedOnProjection"><span class="annot"><span class="annottext">blockedOnProjection :: forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnProjection"><span class="hs-identifier hs-var hs-var">blockedOnProjection</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-var">BlockedOnProj</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span id="local-6989586621682025999"><span id="local-6989586621682026000"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnApplication"><span class="hs-identifier hs-type">blockedOnApplication</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682025999"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#ApplyOrIApply"><span class="hs-identifier hs-type">ApplyOrIApply</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025999"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026000"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-143"></span><span id="blockedOnApplication"><span class="annot"><span class="annottext">blockedOnApplication :: forall (m :: * -&gt; *) a. Monad m =&gt; ApplyOrIApply -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnApplication"><span class="hs-identifier hs-var hs-var">blockedOnApplication</span></a></span></span><span> </span><span id="local-6989586621682026282"><span class="annot"><span class="annottext">ApplyOrIApply
</span><a href="#local-6989586621682026282"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ApplyOrIApply -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnApply"><span class="hs-identifier hs-var">BlockedOnApply</span></a></span><span> </span><span class="annot"><span class="annottext">ApplyOrIApply
</span><a href="#local-6989586621682026282"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#setBlockingVarOverlap"><span class="hs-identifier hs-type">setBlockingVarOverlap</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-type">BlockingVar</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-type">BlockingVar</span></a></span><span>
</span><span id="line-146"></span><span id="setBlockingVarOverlap"><span class="annot"><span class="annottext">setBlockingVarOverlap :: BlockingVar -&gt; BlockingVar
</span><a href="Agda.TypeChecking.Coverage.Match.html#setBlockingVarOverlap"><span class="hs-identifier hs-var hs-var">setBlockingVarOverlap</span></a></span></span><span> </span><span id="local-6989586621682026283"><span class="annot"><span class="annottext">BlockingVar
</span><a href="#local-6989586621682026283"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BlockingVar
</span><a href="#local-6989586621682026283"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#blockingVarOverlap"><span class="hs-identifier hs-var">blockingVarOverlap</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-147"></span><span>
</span><span id="line-148"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#overlapping"><span class="hs-identifier hs-type">overlapping</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier hs-type">BlockingVars</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier hs-type">BlockingVars</span></a></span><span>
</span><span id="line-149"></span><span id="overlapping"><span class="annot"><span class="annottext">overlapping :: BlockingVars -&gt; BlockingVars
</span><a href="Agda.TypeChecking.Coverage.Match.html#overlapping"><span class="hs-identifier hs-var hs-var">overlapping</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(BlockingVar -&gt; BlockingVar) -&gt; BlockingVars -&gt; BlockingVars
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">BlockingVar -&gt; BlockingVar
</span><a href="Agda.TypeChecking.Coverage.Match.html#setBlockingVarOverlap"><span class="hs-identifier hs-var">setBlockingVarOverlap</span></a></span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span class="annot"><span class="hs-comment">-- | Left dominant merge of blocking vars.</span></span><span>
</span><span id="line-152"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#zipBlockingVars"><span class="hs-identifier hs-type">zipBlockingVars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier hs-type">BlockingVars</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier hs-type">BlockingVars</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVars"><span class="hs-identifier hs-type">BlockingVars</span></a></span><span>
</span><span id="line-153"></span><span id="zipBlockingVars"><span class="annot"><span class="annottext">zipBlockingVars :: BlockingVars -&gt; BlockingVars -&gt; BlockingVars
</span><a href="Agda.TypeChecking.Coverage.Match.html#zipBlockingVars"><span class="hs-identifier hs-var hs-var">zipBlockingVars</span></a></span></span><span> </span><span id="local-6989586621682026286"><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026286"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621682026287"><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026287"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(BlockingVar -&gt; BlockingVar) -&gt; BlockingVars -&gt; BlockingVars
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">BlockingVar -&gt; BlockingVar
</span><a href="#local-6989586621682026288"><span class="hs-identifier hs-var">upd</span></a></span><span> </span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026286"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-154"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-155"></span><span>    </span><span id="local-6989586621682026288"><span class="annot"><span class="annottext">upd :: BlockingVar -&gt; BlockingVar
</span><a href="#local-6989586621682026288"><span class="hs-identifier hs-var hs-var">upd</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-type">BlockingVar</span></a></span><span> </span><span id="local-6989586621682026289"><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026289"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621682026290"><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026290"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621682026291"><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026291"><span class="hs-identifier hs-var">lits</span></a></span></span><span> </span><span id="local-6989586621682026292"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026292"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682026293"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026293"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(BlockingVar -&gt; Bool) -&gt; BlockingVars -&gt; Maybe BlockingVar
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><span class="hs-identifier hs-var">List.find</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026289"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Nat -&gt; Nat -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Nat -&gt; Bool) -&gt; (BlockingVar -&gt; Nat) -&gt; BlockingVar -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">BlockingVar -&gt; Nat
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockingVarNo"><span class="hs-identifier hs-var">blockingVarNo</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026287"><span class="hs-identifier hs-var">ys</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-156"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-type">BlockingVar</span></a></span><span> </span><span class="annot"><span class="annottext">Nat
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026295"><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026295"><span class="hs-identifier hs-var">cons'</span></a></span></span><span> </span><span id="local-6989586621682026296"><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026296"><span class="hs-identifier hs-var">lits'</span></a></span></span><span> </span><span id="local-6989586621682026297"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026297"><span class="hs-identifier hs-var">o'</span></a></span></span><span> </span><span id="local-6989586621682026298"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026298"><span class="hs-identifier hs-var">l'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Nat -&gt; [ConHead] -&gt; [Literal] -&gt; Bool -&gt; Bool -&gt; BlockingVar
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-var">BlockingVar</span></a></span><span> </span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026289"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026290"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">[ConHead] -&gt; [ConHead] -&gt; [ConHead]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026295"><span class="hs-identifier hs-var">cons'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026291"><span class="hs-identifier hs-var">lits</span></a></span><span> </span><span class="annot"><span class="annottext">[Literal] -&gt; [Literal] -&gt; [Literal]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026296"><span class="hs-identifier hs-var">lits'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026292"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026297"><span class="hs-identifier hs-var">o'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026293"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026298"><span class="hs-identifier hs-var">l'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-157"></span><span>      </span><span class="annot"><span class="annottext">Maybe BlockingVar
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Nat -&gt; [ConHead] -&gt; [Literal] -&gt; Bool -&gt; Bool -&gt; BlockingVar
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockingVar"><span class="hs-identifier hs-var">BlockingVar</span></a></span><span> </span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026289"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">[ConHead]
</span><a href="#local-6989586621682026290"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">[Literal]
</span><a href="#local-6989586621682026291"><span class="hs-identifier hs-var">lits</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026293"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#setBlockedOnResultOverlap"><span class="hs-identifier hs-type">setBlockedOnResultOverlap</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span>
</span><span id="line-160"></span><span id="setBlockedOnResultOverlap"><span class="annot"><span class="annottext">setBlockedOnResultOverlap :: BlockedOnResult -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#setBlockedOnResultOverlap"><span class="hs-identifier hs-var hs-var">setBlockedOnResultOverlap</span></a></span></span><span> </span><span id="local-6989586621682026301"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026301"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026301"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-161"></span><span>  </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-type">BlockedOnProj</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026301"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnResultOverlap"><span class="hs-identifier hs-var">blockedOnResultOverlap</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-162"></span><span>  </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnApply"><span class="hs-identifier hs-type">BlockedOnApply</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026301"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-163"></span><span>  </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-type">NotBlockedOnResult</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026301"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#anyBlockedOnResult"><span class="hs-identifier hs-type">anyBlockedOnResult</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span>
</span><span id="line-166"></span><span id="anyBlockedOnResult"><span class="annot"><span class="annottext">anyBlockedOnResult :: BlockedOnResult -&gt; BlockedOnResult -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#anyBlockedOnResult"><span class="hs-identifier hs-var hs-var">anyBlockedOnResult</span></a></span></span><span> </span><span id="local-6989586621682026303"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026303"><span class="hs-identifier hs-var">b1</span></a></span></span><span> </span><span id="local-6989586621682026304"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026304"><span class="hs-identifier hs-var">b2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026303"><span class="hs-identifier hs-var">b1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026304"><span class="hs-identifier hs-var">b2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-167"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-var">NotBlockedOnResult</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621682026305"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026305"><span class="hs-identifier hs-var">b2</span></a></span></span><span>                </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026305"><span class="hs-identifier hs-var">b2</span></a></span><span>
</span><span id="line-168"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621682026306"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026306"><span class="hs-identifier hs-var">b1</span></a></span></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-var">NotBlockedOnResult</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026306"><span class="hs-identifier hs-var">b1</span></a></span><span>
</span><span id="line-169"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult
</span><span class="hs-identifier">_</span></span><span>                  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="annot"><span class="hs-comment">-- | Left dominant merge of `BlockedOnResult`.</span></span><span>
</span><span id="line-172"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#choiceBlockedOnResult"><span class="hs-identifier hs-type">choiceBlockedOnResult</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnResult"><span class="hs-identifier hs-type">BlockedOnResult</span></a></span><span>
</span><span id="line-173"></span><span id="choiceBlockedOnResult"><span class="annot"><span class="annottext">choiceBlockedOnResult :: BlockedOnResult -&gt; BlockedOnResult -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#choiceBlockedOnResult"><span class="hs-identifier hs-var hs-var">choiceBlockedOnResult</span></a></span></span><span> </span><span id="local-6989586621682026309"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026309"><span class="hs-identifier hs-var">b1</span></a></span></span><span> </span><span id="local-6989586621682026310"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026310"><span class="hs-identifier hs-var">b2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026309"><span class="hs-identifier hs-var">b1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026310"><span class="hs-identifier hs-var">b2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-174"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-var">NotBlockedOnResult</span></a></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#NotBlockedOnResult"><span class="hs-identifier hs-var">NotBlockedOnResult</span></a></span><span>
</span><span id="line-175"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-type">BlockedOnProj</span></a></span><span> </span><span id="local-6989586621682026311"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026311"><span class="hs-identifier hs-var">o1</span></a></span></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-type">BlockedOnProj</span></a></span><span> </span><span id="local-6989586621682026312"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026312"><span class="hs-identifier hs-var">o2</span></a></span></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-var">BlockedOnProj</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026311"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682026312"><span class="hs-identifier hs-var">o2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-type">BlockedOnProj</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnProj"><span class="hs-identifier hs-var">BlockedOnProj</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-177"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnApply"><span class="hs-identifier hs-type">BlockedOnApply</span></a></span><span> </span><span id="local-6989586621682026313"><span class="annot"><span class="annottext">ApplyOrIApply
</span><a href="#local-6989586621682026313"><span class="hs-identifier hs-var">b</span></a></span></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ApplyOrIApply -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#BlockedOnApply"><span class="hs-identifier hs-var">BlockedOnApply</span></a></span><span> </span><span class="annot"><span class="annottext">ApplyOrIApply
</span><a href="#local-6989586621682026313"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-178"></span><span>
</span><span id="line-179"></span><span class="hs-comment">-- | @choice m m'@ combines the match results @m@ of a function clause</span><span>
</span><span id="line-180"></span><span class="hs-comment">--   with the (already combined) match results $m'$ of the later clauses.</span><span>
</span><span id="line-181"></span><span class="hs-comment">--   It is for skipping clauses that definitely do not match ('No').</span><span>
</span><span id="line-182"></span><span class="hs-comment">--   It is left-strict, to be used with @foldr@.</span><span>
</span><span id="line-183"></span><span class="hs-comment">--   If one clause unconditionally matches ('Yes') we do not look further.</span><span>
</span><span id="line-184"></span><span id="local-6989586621682025938"><span id="local-6989586621682025939"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#choice"><span class="hs-identifier hs-type">choice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682025938"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025938"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025939"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025938"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025939"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025938"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025939"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-185"></span><span id="choice"><span class="annot"><span class="annottext">choice :: forall (m :: * -&gt; *) a.
Monad m =&gt;
m (Match a) -&gt; m (Match a) -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#choice"><span class="hs-identifier hs-var hs-var">choice</span></a></span></span><span> </span><span id="local-6989586621682026321"><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026321"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621682026322"><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026322"><span class="hs-identifier hs-var">m'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026321"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">m (Match a) -&gt; (Match a -&gt; m (Match a)) -&gt; m (Match a)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-186"></span><span>  </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621682026323"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026323"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Match a)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026323"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-187"></span><span>  </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-type">Block</span></a></span><span> </span><span id="local-6989586621682026324"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026324"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621682026325"><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026325"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026322"><span class="hs-identifier hs-var">m'</span></a></span><span> </span><span class="annot"><span class="annottext">m (Match a) -&gt; (Match a -&gt; m (Match a)) -&gt; m (Match a)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-188"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-type">Block</span></a></span><span> </span><span id="local-6989586621682026326"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026326"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621682026327"><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026327"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockedOnResult -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#choiceBlockedOnResult"><span class="hs-identifier hs-var">choiceBlockedOnResult</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026324"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026326"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(BlockingVars -&gt; Match a) -&gt; BlockingVars -&gt; Match a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockingVars -&gt; BlockingVars -&gt; BlockingVars
</span><a href="Agda.TypeChecking.Coverage.Match.html#zipBlockingVars"><span class="hs-identifier hs-var">zipBlockingVars</span></a></span><span> </span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026325"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026327"><span class="hs-identifier hs-var">ys</span></a></span><span>
</span><span id="line-189"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#setBlockedOnResultOverlap"><span class="hs-identifier hs-var">setBlockedOnResultOverlap</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026324"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(BlockingVars -&gt; Match a) -&gt; BlockingVars -&gt; Match a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockingVars -&gt; BlockingVars
</span><a href="Agda.TypeChecking.Coverage.Match.html#overlapping"><span class="hs-identifier hs-var">overlapping</span></a></span><span> </span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026325"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-190"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026324"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026325"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-191"></span><span>  </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026322"><span class="hs-identifier hs-var">m'</span></a></span><span>
</span><span id="line-192"></span><span>
</span><span id="line-193"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchClause"><span class="hs-pragma hs-type">matchClause</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-pragma hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-pragma hs-type">SplitPattern</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Clause"><span class="hs-pragma hs-type">Clause</span></a></span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#MatchResult"><span class="hs-pragma hs-type">MatchResult</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-194"></span><span id="local-6989586621682025957"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchClause"><span class="hs-identifier hs-type">matchClause</span></a></span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682025957"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-196"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-identifier hs-type">SplitPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-197"></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Split clause patterns @qs@.</span></span><span>
</span><span id="line-198"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Clause"><span class="hs-identifier hs-type">Clause</span></a></span><span>
</span><span id="line-199"></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Clause @c@ to cover split clause.</span></span><span>
</span><span id="line-200"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682025957"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#MatchResult"><span class="hs-identifier hs-type">MatchResult</span></a></span></span><span>
</span><span id="line-201"></span><span>     </span><span class="hs-comment">-- ^ Result.</span><span>
</span><span id="line-202"></span><span>     </span><span class="hs-comment">--   If 'Yes' the instantiation @rs@ such that @(namedClausePats c)[rs] == qs@.</span><span>
</span><span id="line-203"></span><span id="matchClause"><span class="annot"><span class="annottext">matchClause :: forall (m :: * -&gt; *).
PureTCM m =&gt;
[NamedArg SplitPattern]
-&gt; Clause -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchClause"><span class="hs-identifier hs-var hs-var">matchClause</span></a></span></span><span> </span><span id="local-6989586621682026332"><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026332"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span id="local-6989586621682026333"><span class="annot"><span class="annottext">Clause
</span><a href="#local-6989586621682026333"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' DBPatVar)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
(PureTCM m, DeBruijn a) =&gt;
[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var">matchPats</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Clause -&gt; [NamedArg (Pattern' DBPatVar)]
</span><a href="Agda.Syntax.Internal.html#namedClausePats"><span class="hs-identifier hs-var">namedClausePats</span></a></span><span> </span><span class="annot"><span class="annottext">Clause
</span><a href="#local-6989586621682026333"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026332"><span class="hs-identifier hs-var">qs</span></a></span><span>
</span><span id="line-204"></span><span>
</span><span id="line-205"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-pragma hs-type">matchPats</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span id="local-6989586621682026336"><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-pragma hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026336"><span class="hs-pragma hs-type">a</span></a></span><span> </span><span class="hs-pragma">=&gt;</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-pragma hs-type">NamedArg</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-pragma hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026336"><span class="hs-pragma hs-type">a</span></a></span><span class="hs-pragma">)</span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-pragma hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-pragma hs-type">SplitPattern</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#MatchResult"><span class="hs-pragma hs-type">MatchResult</span></a></span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-206"></span><span class="hs-comment">-- | @matchPats ps qs@ checks whether a function clause with patterns</span><span>
</span><span id="line-207"></span><span class="hs-comment">--   @ps@ covers a split clause with patterns @qs@.</span><span>
</span><span id="line-208"></span><span class="hs-comment">--</span><span>
</span><span id="line-209"></span><span class="hs-comment">--   Issue #842 / #1986: This is accepted:</span><span>
</span><span id="line-210"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-211"></span><span class="hs-comment">--     F : Bool -&gt; Set1</span><span>
</span><span id="line-212"></span><span class="hs-comment">--     F true = Set</span><span>
</span><span id="line-213"></span><span class="hs-comment">--     F      = \ x -&gt; Set</span><span>
</span><span id="line-214"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-215"></span><span class="hs-comment">--   For the second clause, the split clause is @F false@,</span><span>
</span><span id="line-216"></span><span class="hs-comment">--   so there are more patterns in the split clause than</span><span>
</span><span id="line-217"></span><span class="hs-comment">--   in the considered clause.  These additional patterns</span><span>
</span><span id="line-218"></span><span class="hs-comment">--   are simply dropped by @zipWith@.  This will result</span><span>
</span><span id="line-219"></span><span class="hs-comment">--   in @mconcat []@ which is @Yes []@.</span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span id="local-6989586621682026017"><span id="local-6989586621682026018"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-type">matchPats</span></a></span><span>
</span><span id="line-222"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026017"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-identifier hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026018"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-223"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026018"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-224"></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Clause pattern vector @ps@ (to cover split clause pattern vector).</span></span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-identifier hs-type">SplitPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-226"></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Split clause pattern vector @qs@ (to be covered by clause pattern vector).</span></span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026017"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#MatchResult"><span class="hs-identifier hs-type">MatchResult</span></a></span></span></span><span>
</span><span id="line-228"></span><span>     </span><span class="hs-comment">-- ^ Result.</span><span>
</span><span id="line-229"></span><span>     </span><span class="hs-comment">--   If 'Yes' the instantiation @rs@ such that @ps[rs] == qs@.</span><span>
</span><span id="line-230"></span><span id="matchPats"><span class="annot"><span class="annottext">matchPats :: forall (m :: * -&gt; *) a.
(PureTCM m, DeBruijn a) =&gt;
[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var hs-var">matchPats</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern) -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-231"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var">matchPats</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621682026365"><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026365"><span class="hs-identifier hs-var">p</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621682026366"><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682026366"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621682026367"><span class="annot"><span class="annottext">NamedArg SplitPattern
</span><a href="#local-6989586621682026367"><span class="hs-identifier hs-var">q</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621682026368"><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026368"><span class="hs-identifier hs-var">qs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-232"></span><span>  </span><span class="annot"><span class="annottext">Pattern' a -&gt; SplitPattern -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
(PureTCM m, DeBruijn a) =&gt;
Pattern' a -&gt; SplitPattern -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchPat"><span class="hs-identifier hs-var">matchPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NamedArg (Pattern' a) -&gt; Pattern' a
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026365"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NamedArg SplitPattern -&gt; SplitPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span> </span><span class="annot"><span class="annottext">NamedArg SplitPattern
</span><a href="#local-6989586621682026367"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
-&gt; m (Match (DList (Nat, SplitPattern)))
-&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
(Monad m, Semigroup a) =&gt;
m (Match a) -&gt; m (Match a) -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#combine"><span class="hs-operator hs-var">`combine`</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
(PureTCM m, DeBruijn a) =&gt;
[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var">matchPats</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682026366"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026368"><span class="hs-identifier hs-var">qs</span></a></span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span class="hs-comment">-- Patterns left in split clause:</span><span>
</span><span id="line-235"></span><span class="hs-comment">-- Andreas, 2016-06-03, issue #1986:</span><span>
</span><span id="line-236"></span><span class="hs-comment">-- catch-all for copatterns is inconsistent as found by Ulf.</span><span>
</span><span id="line-237"></span><span class="hs-comment">-- Thus, if the split clause has copatterns left,</span><span>
</span><span id="line-238"></span><span class="hs-comment">-- the current (shorter) clause is not considered covering.</span><span>
</span><span id="line-239"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var">matchPats</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621682026372"><span class="annot"><span class="annottext">qs :: [NamedArg SplitPattern]
</span><a href="#local-6989586621682026372"><span class="hs-identifier hs-var">qs</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="annottext">NamedArg SplitPattern
</span><span class="hs-identifier">_</span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(NamedArg SplitPattern -&gt; Maybe (ProjOrigin, AmbiguousQName))
-&gt; [NamedArg SplitPattern] -&gt; [(ProjOrigin, AmbiguousQName)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">NamedArg SplitPattern -&gt; Maybe (ProjOrigin, AmbiguousQName)
forall a. IsProjP a =&gt; a -&gt; Maybe (ProjOrigin, AmbiguousQName)
</span><a href="Agda.Syntax.Abstract.Name.html#isProjP"><span class="hs-identifier hs-var">isProjP</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026372"><span class="hs-identifier hs-var">qs</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-240"></span><span>  </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern) -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-comment">-- no proj. patterns left</span><span>
</span><span id="line-241"></span><span>  </span><span class="annot"><span class="annottext">[(ProjOrigin, AmbiguousQName)]
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>         </span><span class="hs-comment">-- proj. patterns left</span><span>
</span><span id="line-242"></span><span>
</span><span id="line-243"></span><span class="hs-comment">-- Patterns left in candidate clause:</span><span>
</span><span id="line-244"></span><span class="hs-comment">-- If the current clause has additional copatterns in</span><span>
</span><span id="line-245"></span><span class="hs-comment">-- comparison to the split clause, we should split on them.</span><span>
</span><span id="line-246"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var">matchPats</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621682026374"><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026374"><span class="hs-identifier hs-var">p</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621682026375"><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682026375"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a) -&gt; Maybe (ProjOrigin, AmbiguousQName)
forall a. IsProjP a =&gt; a -&gt; Maybe (ProjOrigin, AmbiguousQName)
</span><a href="Agda.Syntax.Abstract.Name.html#isProjP"><span class="hs-identifier hs-var">isProjP</span></a></span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026374"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-247"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnProjection"><span class="hs-identifier hs-var">blockedOnProjection</span></a></span><span>
</span><span id="line-248"></span><span>  </span><span class="annot"><span class="annottext">Maybe (ProjOrigin, AmbiguousQName)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ApplyOrIApply -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; ApplyOrIApply -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnApplication"><span class="hs-identifier hs-var">blockedOnApplication</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a) -&gt; Pattern' a
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026374"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ApplyOrIApply
</span><a href="Agda.TypeChecking.Coverage.Match.html#IsIApply"><span class="hs-identifier hs-var">IsIApply</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Pattern' a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ApplyOrIApply
</span><a href="Agda.TypeChecking.Coverage.Match.html#IsApply"><span class="hs-identifier hs-var">IsApply</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-249"></span><span>
</span><span id="line-250"></span><span class="hs-comment">-- | Combine results of checking whether function clause patterns</span><span>
</span><span id="line-251"></span><span class="hs-comment">--   covers split clause patterns.</span><span>
</span><span id="line-252"></span><span class="hs-comment">--</span><span>
</span><span id="line-253"></span><span class="hs-comment">--   'No' is dominant: if one function clause pattern is disjoint to</span><span>
</span><span id="line-254"></span><span class="hs-comment">--   the corresponding split clause pattern, then</span><span>
</span><span id="line-255"></span><span class="hs-comment">--   the whole clauses are disjoint.</span><span>
</span><span id="line-256"></span><span class="hs-comment">--</span><span>
</span><span id="line-257"></span><span class="hs-comment">--   'Yes' is neutral: for a match, all patterns have to match.</span><span>
</span><span id="line-258"></span><span class="hs-comment">--</span><span>
</span><span id="line-259"></span><span class="hs-comment">--   'Block' accumulates variables of the split clause</span><span>
</span><span id="line-260"></span><span class="hs-comment">--   that have to be instantiated (an projection names of copattern matches)</span><span>
</span><span id="line-261"></span><span class="hs-comment">--   to make the split clause an instance of the function clause.</span><span>
</span><span id="line-262"></span><span id="local-6989586621682026035"><span id="local-6989586621682026036"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#combine"><span class="hs-identifier hs-type">combine</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621682026035"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="annot"><a href="#local-6989586621682026036"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026035"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026036"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026035"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026036"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026035"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026036"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-263"></span><span id="combine"><span class="annot"><span class="annottext">combine :: forall (m :: * -&gt; *) a.
(Monad m, Semigroup a) =&gt;
m (Match a) -&gt; m (Match a) -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#combine"><span class="hs-identifier hs-var hs-var">combine</span></a></span></span><span> </span><span id="local-6989586621682026389"><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026389"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621682026390"><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026390"><span class="hs-identifier hs-var">m'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026389"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">m (Match a) -&gt; (Match a -&gt; m (Match a)) -&gt; m (Match a)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-264"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621682026391"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026391"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026390"><span class="hs-identifier hs-var">m'</span></a></span><span> </span><span class="annot"><span class="annottext">m (Match a) -&gt; (Match a -&gt; m (Match a)) -&gt; m (Match a)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-265"></span><span>      </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621682026392"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026392"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Match a)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026391"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026392"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>      </span><span id="local-6989586621682026393"><span class="annot"><span class="annottext">Match a
</span><a href="#local-6989586621682026393"><span class="hs-identifier hs-var">y</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><a href="#local-6989586621682026393"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-267"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match a)
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-268"></span><span>    </span><span id="local-6989586621682026394"><span class="annot"><span class="annottext">x :: Match a
</span><a href="#local-6989586621682026394"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-type">Block</span></a></span><span> </span><span id="local-6989586621682026395"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026395"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621682026396"><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026396"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match a)
</span><a href="#local-6989586621682026390"><span class="hs-identifier hs-var">m'</span></a></span><span> </span><span class="annot"><span class="annottext">m (Match a) -&gt; (Match a -&gt; m (Match a)) -&gt; m (Match a)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-269"></span><span>      </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match a)
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-270"></span><span>      </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-type">Block</span></a></span><span> </span><span id="local-6989586621682026397"><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026397"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621682026398"><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026398"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match a -&gt; m (Match a)) -&gt; Match a -&gt; m (Match a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockingVars -&gt; Match a
forall a. BlockedOnResult -&gt; BlockingVars -&gt; Match a
</span><a href="Agda.TypeChecking.Coverage.Match.html#Block"><span class="hs-identifier hs-var">Block</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockedOnResult -&gt; BlockedOnResult -&gt; BlockedOnResult
</span><a href="Agda.TypeChecking.Coverage.Match.html#anyBlockedOnResult"><span class="hs-identifier hs-var">anyBlockedOnResult</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026395"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">BlockedOnResult
</span><a href="#local-6989586621682026397"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026396"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">BlockingVars -&gt; BlockingVars -&gt; BlockingVars
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">BlockingVars
</span><a href="#local-6989586621682026398"><span class="hs-identifier hs-var">ys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-271"></span><span>      </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; m (Match a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><a href="#local-6989586621682026394"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-272"></span><span>
</span><span id="line-273"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchPat"><span class="hs-pragma hs-type">matchPat</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span id="local-6989586621682026399"><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-pragma hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026399"><span class="hs-pragma hs-type">a</span></a></span><span> </span><span class="hs-pragma">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-pragma hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026399"><span class="hs-pragma hs-type">a</span></a></span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-pragma hs-type">SplitPattern</span></a></span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#MatchResult"><span class="hs-pragma hs-type">MatchResult</span></a></span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-274"></span><span class="hs-comment">-- | @matchPat p q@ checks whether a function clause pattern @p@</span><span>
</span><span id="line-275"></span><span class="hs-comment">--   covers a split clause pattern @q@.  There are three results:</span><span>
</span><span id="line-276"></span><span class="hs-comment">--</span><span>
</span><span id="line-277"></span><span class="hs-comment">--   1. @Yes rs@ means it covers, because @p@ is a variable pattern. @rs@ collects</span><span>
</span><span id="line-278"></span><span class="hs-comment">--      the instantiations of the variables in @p@ s.t. @p[rs] = q@.</span><span>
</span><span id="line-279"></span><span class="hs-comment">--</span><span>
</span><span id="line-280"></span><span class="hs-comment">--   2. @No@ means it does not cover.</span><span>
</span><span id="line-281"></span><span class="hs-comment">--</span><span>
</span><span id="line-282"></span><span class="hs-comment">--   3. @Block [x]@ means @p@ is a proper instance of @q@ and could become</span><span>
</span><span id="line-283"></span><span class="hs-comment">--      a cover if @q@ was split on variable @x@.</span><span>
</span><span id="line-284"></span><span>
</span><span id="line-285"></span><span id="local-6989586621682026032"><span id="local-6989586621682026033"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#matchPat"><span class="hs-identifier hs-type">matchPat</span></a></span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026032"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-identifier hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026033"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026033"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-288"></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Clause pattern @p@ (to cover split clause pattern).</span></span><span>
</span><span id="line-289"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.SplitPattern.html#SplitPattern"><span class="hs-identifier hs-type">SplitPattern</span></a></span><span>
</span><span id="line-290"></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Split clause pattern @q@ (to be covered by clause pattern).</span></span><span>
</span><span id="line-291"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026032"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#MatchResult"><span class="hs-identifier hs-type">MatchResult</span></a></span></span></span><span>
</span><span id="line-292"></span><span>     </span><span class="hs-comment">-- ^ Result.</span><span>
</span><span id="line-293"></span><span>     </span><span class="hs-comment">--   If 'Yes', also the instantiation @rs@ of the clause pattern variables</span><span>
</span><span id="line-294"></span><span>     </span><span class="hs-comment">--   to produce the split clause pattern, @p[rs] = q@.</span><span>
</span><span id="line-295"></span><span id="matchPat"><span class="annot"><span class="annottext">matchPat :: forall (m :: * -&gt; *) a.
(PureTCM m, DeBruijn a) =&gt;
Pattern' a -&gt; SplitPattern -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchPat"><span class="hs-identifier hs-var hs-var">matchPat</span></a></span></span><span> </span><span id="local-6989586621682026485"><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682026485"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621682026486"><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682026485"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-296"></span><span>
</span><span id="line-297"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026488"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026488"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-298"></span><span>    </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern) -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="annot"><span class="annottext">(DList (Nat, SplitPattern)
 -&gt; m (Match (DList (Nat, SplitPattern))))
-&gt; DList (Nat, SplitPattern)
-&gt; m (Match (DList (Nat, SplitPattern)))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Nat, SplitPattern) -&gt; DList (Nat, SplitPattern)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Nat -&gt; Maybe Nat -&gt; Nat
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Nat
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; Maybe Nat
forall a. DeBruijn a =&gt; a -&gt; Maybe Nat
</span><a href="Agda.TypeChecking.Substitute.DeBruijn.html#deBruijnView"><span class="hs-identifier hs-var">deBruijnView</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026488"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern) -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-301"></span><span>  </span><span class="hs-comment">-- Jesper, 2014-11-04: putting 'Yes [q]' here triggers issue 1333.</span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-comment">-- Not checking for trivial patterns should be safe here, as dot patterns are</span><span>
</span><span id="line-303"></span><span>  </span><span class="hs-comment">-- guaranteed to match if the rest of the pattern does, so some extra splitting</span><span>
</span><span id="line-304"></span><span>  </span><span class="hs-comment">-- on them doesn't change the reduction behaviour.</span><span>
</span><span id="line-305"></span><span>
</span><span id="line-306"></span><span>  </span><span id="local-6989586621682026492"><span class="annot"><span class="annottext">p :: Pattern' a
</span><a href="#local-6989586621682026492"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026494"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026494"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-307"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026495"><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026495"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026494"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; [Literal] -&gt; Bool
forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">SplitPatVar -&gt; [Literal]
</span><a href="Agda.TypeChecking.Coverage.SplitPattern.html#splitExcludedLits"><span class="hs-identifier hs-var">splitExcludedLits</span></a></span><span> </span><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026495"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-308"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-309"></span><span>                </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Nat -&gt; Literal -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; Nat -&gt; Literal -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnLiteral"><span class="hs-identifier hs-var">blockedOnLiteral</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SplitPatVar -&gt; Nat
</span><a href="Agda.TypeChecking.Coverage.SplitPattern.html#splitPatVarIndex"><span class="hs-identifier hs-var">splitPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026495"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026494"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-310"></span><span>    </span><span class="annot"><span class="annottext">SplitPattern
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SplitPattern -&gt; m (Maybe Literal)
forall (m :: * -&gt; *) a.
PureTCM m =&gt;
Pattern' a -&gt; m (Maybe Literal)
</span><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-var">isLitP</span></a></span><span> </span><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">m (Maybe Literal)
-&gt; (Maybe Literal -&gt; m (Match (DList (Nat, SplitPattern))))
-&gt; m (Match (DList (Nat, SplitPattern)))
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-311"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621682026500"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026500"><span class="hs-identifier hs-var">l'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026494"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Literal -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026500"><span class="hs-identifier hs-var">l'</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern) -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-312"></span><span>      </span><span class="annot"><span class="annottext">Maybe Literal
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026502"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682026502"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-315"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026503"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682026503"><span class="hs-identifier hs-var">d'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-316"></span><span>      </span><span id="local-6989586621682026504"><span class="annot"><a href="#local-6989586621682026504"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">QName -&gt; m QName
forall (m :: * -&gt; *). HasConstInfo m =&gt; QName -&gt; m QName
</span><a href="Agda.TypeChecking.Monad.Signature.html#getOriginalProjection"><span class="hs-identifier hs-var">getOriginalProjection</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682026502"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-317"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621682026504"><span class="hs-identifier hs-type">d</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">==</span></span><span> </span><span class="annot"><a href="#local-6989586621682026503"><span class="hs-identifier hs-type">d'</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-type">yes</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">mempty</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-type">no</span></a></span><span>
</span><span id="line-318"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>  </span><span class="hs-comment">-- not impossible, see issue #7753</span><span>
</span><span id="line-319"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-320"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-321"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-322"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-323"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-324"></span><span>
</span><span id="line-325"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026508"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026508"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-326"></span><span>    </span><span class="annot"><span class="annottext">DList (Nat, SplitPattern) -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#yes"><span class="hs-identifier hs-var">yes</span></a></span><span> </span><span class="annot"><span class="annottext">(DList (Nat, SplitPattern)
 -&gt; m (Match (DList (Nat, SplitPattern))))
-&gt; DList (Nat, SplitPattern)
-&gt; m (Match (DList (Nat, SplitPattern)))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Nat, SplitPattern) -&gt; DList (Nat, SplitPattern)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Nat -&gt; Maybe Nat -&gt; Nat
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Nat
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; Maybe Nat
forall a. DeBruijn a =&gt; a -&gt; Maybe Nat
</span><a href="Agda.TypeChecking.Substitute.DeBruijn.html#deBruijnView"><span class="hs-identifier hs-var">deBruijnView</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682026508"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span>                           </span><span class="hs-comment">--    Issue #4179: If the inferred pattern is a literal</span><span>
</span><span id="line-329"></span><span>                           </span><span class="hs-comment">-- v  we need to turn it into a constructor pattern.</span><span>
</span><span id="line-330"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682026509"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026509"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682026510"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026510"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span id="local-6989586621682026511"><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682026511"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SplitPattern -&gt; m SplitPattern
forall (m :: * -&gt; *) a.
(MonadReduce m, DeBruijn a) =&gt;
Pattern' a -&gt; m (Pattern' a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#unDotP"><span class="hs-identifier hs-var">unDotP</span></a></span><span> </span><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">m SplitPattern
-&gt; (SplitPattern -&gt; m SplitPattern) -&gt; m SplitPattern
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">SplitPattern -&gt; m SplitPattern
forall (m :: * -&gt; *) a.
HasBuiltins m =&gt;
Pattern' a -&gt; m (Pattern' a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#unLitP"><span class="hs-identifier hs-var">unLitP</span></a></span><span> </span><span class="annot"><span class="annottext">m SplitPattern
-&gt; (SplitPattern -&gt; m (Match (DList (Nat, SplitPattern))))
-&gt; m (Match (DList (Nat, SplitPattern)))
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-331"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026514"><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026514"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Nat
-&gt; ConHead
-&gt; ConPatternInfo
-&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
Monad m =&gt;
Nat -&gt; ConHead -&gt; ConPatternInfo -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnConstructor"><span class="hs-identifier hs-var">blockedOnConstructor</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SplitPatVar -&gt; Nat
</span><a href="Agda.TypeChecking.Coverage.SplitPattern.html#splitPatVarIndex"><span class="hs-identifier hs-var">splitPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026514"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026509"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026510"><span class="hs-identifier hs-var">ci</span></a></span><span>
</span><span id="line-332"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682026515"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026515"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span id="local-6989586621682026516"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026516"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621682026517"><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026517"><span class="hs-identifier hs-var">qs</span></a></span></span><span>
</span><span id="line-333"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026509"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConHead -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026515"><span class="hs-identifier hs-var">c'</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
(PureTCM m, DeBruijn a) =&gt;
[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var">matchPats</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682026511"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026517"><span class="hs-identifier hs-var">qs</span></a></span><span>
</span><span id="line-334"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-335"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span id="local-6989586621682026518"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026518"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682026519"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026519"><span class="hs-identifier hs-var">t</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-336"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-337"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>  </span><span class="hs-comment">-- excluded by typing and unLitP</span><span>
</span><span id="line-338"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>  </span><span class="hs-comment">-- excluded by typing</span><span>
</span><span id="line-339"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026520"><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026520"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Nat
-&gt; ConHead
-&gt; ConPatternInfo
-&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
Monad m =&gt;
Nat -&gt; ConHead -&gt; ConPatternInfo -&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#blockedOnConstructor"><span class="hs-identifier hs-var">blockedOnConstructor</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SplitPatVar -&gt; Nat
</span><a href="Agda.TypeChecking.Coverage.SplitPattern.html#splitPatVarIndex"><span class="hs-identifier hs-var">splitPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026520"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026509"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026510"><span class="hs-identifier hs-var">ci</span></a></span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span> </span><span id="local-6989586621682026521"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026521"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682026522"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682026522"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682026523"><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682026523"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SplitPattern -&gt; m SplitPattern
forall (m :: * -&gt; *) a.
(MonadReduce m, DeBruijn a) =&gt;
Pattern' a -&gt; m (Pattern' a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#unDotP"><span class="hs-identifier hs-var">unDotP</span></a></span><span> </span><span class="annot"><span class="annottext">SplitPattern
</span><a href="#local-6989586621682026486"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">m SplitPattern
-&gt; (SplitPattern -&gt; m (Match (DList (Nat, SplitPattern))))
-&gt; m (Match (DList (Nat, SplitPattern)))
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-342"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026524"><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026524"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-343"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682026525"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026525"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span id="local-6989586621682026526"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026526"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621682026527"><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026527"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-344"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span id="local-6989586621682026528"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026528"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682026529"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026529"><span class="hs-identifier hs-var">t</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-345"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-346"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span> </span><span id="local-6989586621682026530"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026530"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682026531"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682026531"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span id="local-6989586621682026532"><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026532"><span class="hs-identifier hs-var">qs</span></a></span></span><span>
</span><span id="line-347"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682026522"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">QName -&gt; QName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682026531"><span class="hs-identifier hs-var">c'</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a.
(PureTCM m, DeBruijn a) =&gt;
[NamedArg (Pattern' a)]
-&gt; [NamedArg SplitPattern] -&gt; m (Match (DList (Nat, SplitPattern)))
</span><a href="Agda.TypeChecking.Coverage.Match.html#matchPats"><span class="hs-identifier hs-var">matchPats</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682026523"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg SplitPattern]
</span><a href="#local-6989586621682026532"><span class="hs-identifier hs-var">qs</span></a></span><span>
</span><span id="line-348"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall (m :: * -&gt; *) a. Monad m =&gt; m (Match a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#no"><span class="hs-identifier hs-var">no</span></a></span><span>
</span><span id="line-349"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>  </span><span class="hs-comment">-- excluded by typing</span><span>
</span><span id="line-350"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026533"><span class="annot"><span class="annottext">SplitPatVar
</span><a href="#local-6989586621682026533"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match (DList (Nat, SplitPattern)))
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="hs-comment">-- blockedOnConstructor (splitPatVarIndex x) c</span><span>
</span><span id="line-351"></span><span>
</span><span id="line-352"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#unDotP"><span class="hs-pragma hs-type">unDotP</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span id="local-6989586621682026534"><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-pragma hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026534"><span class="hs-pragma hs-type">a</span></a></span><span> </span><span class="hs-pragma">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-pragma hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026534"><span class="hs-pragma hs-type">a</span></a></span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-pragma hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026534"><span class="hs-pragma hs-type">a</span></a></span><span class="hs-pragma">)</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-353"></span><span class="annot"><span class="hs-comment">-- | Unfold one level of a dot pattern to a proper pattern if possible.</span></span><span>
</span><span id="line-354"></span><span id="local-6989586621682026063"><span id="local-6989586621682026064"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#unDotP"><span class="hs-identifier hs-type">unDotP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#MonadReduce"><span class="hs-identifier hs-type">MonadReduce</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026063"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-identifier hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026064"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026064"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026063"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026064"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-355"></span><span id="unDotP"><span class="annot"><span class="annottext">unDotP :: forall (m :: * -&gt; *) a.
(MonadReduce m, DeBruijn a) =&gt;
Pattern' a -&gt; m (Pattern' a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#unDotP"><span class="hs-identifier hs-var hs-var">unDotP</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span id="local-6989586621682026556"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026556"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682026557"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026557"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; m Term
forall a (m :: * -&gt; *). (Reduce a, MonadReduce m) =&gt; a -&gt; m a
</span><a href="Agda.TypeChecking.Reduce.html#reduce"><span class="hs-identifier hs-var">reduce</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026557"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">m Term -&gt; (Term -&gt; m (Pattern' a)) -&gt; m (Pattern' a)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-356"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#Var"><span class="hs-identifier hs-type">Var</span></a></span><span> </span><span id="local-6989586621682026560"><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026560"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; m (Pattern' a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Pattern' a -&gt; m (Pattern' a)) -&gt; Pattern' a -&gt; m (Pattern' a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Nat -&gt; Pattern' a
forall a. DeBruijn a =&gt; Nat -&gt; a
</span><a href="Agda.TypeChecking.Substitute.DeBruijn.html#deBruijnVar"><span class="hs-identifier hs-var">deBruijnVar</span></a></span><span> </span><span class="annot"><span class="annottext">Nat
</span><a href="#local-6989586621682026560"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-357"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span id="local-6989586621682026563"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026563"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="annot"><span class="annottext">ConInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026564"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682026564"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-358"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682026565"><span class="annot"><span class="annottext">ps :: [Arg (Named NamedName (Pattern' a))]
</span><a href="#local-6989586621682026565"><span class="hs-identifier hs-var hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; Arg (Named NamedName (Pattern' a)))
-&gt; [Arg Term] -&gt; [Arg (Named NamedName (Pattern' a))]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Term -&gt; Named NamedName (Pattern' a))
-&gt; Arg Term -&gt; Arg (Named NamedName (Pattern' a))
forall a b. (a -&gt; b) -&gt; Arg a -&gt; Arg b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">((Term -&gt; Named NamedName (Pattern' a))
 -&gt; Arg Term -&gt; Arg (Named NamedName (Pattern' a)))
-&gt; (Term -&gt; Named NamedName (Pattern' a))
-&gt; Arg Term
-&gt; Arg (Named NamedName (Pattern' a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; Named NamedName (Pattern' a)
forall a name. a -&gt; Named name a
</span><a href="Agda.Syntax.Common.html#unnamed"><span class="hs-identifier hs-var">unnamed</span></a></span><span> </span><span class="annot"><span class="annottext">(Pattern' a -&gt; Named NamedName (Pattern' a))
-&gt; (Term -&gt; Pattern' a) -&gt; Term -&gt; Named NamedName (Pattern' a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">PatternInfo -&gt; Term -&gt; Pattern' a
forall x. PatternInfo -&gt; Term -&gt; Pattern' x
</span><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-var">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026556"><span class="hs-identifier hs-var">o</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Arg Term] -&gt; [Arg (Named NamedName (Pattern' a))])
-&gt; [Arg Term] -&gt; [Arg (Named NamedName (Pattern' a))]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Arg Term] -&gt; Maybe [Arg Term] -&gt; [Arg Term]
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe [Arg Term] -&gt; [Arg Term]) -&gt; Maybe [Arg Term] -&gt; [Arg Term]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Elim] -&gt; Maybe [Arg Term]
forall a. [Elim' a] -&gt; Maybe [Arg a]
</span><a href="Agda.Syntax.Internal.Elim.html#allApplyElims"><span class="hs-identifier hs-var">allApplyElims</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682026564"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-359"></span><span>    </span><span class="annot"><span class="annottext">Pattern' a -&gt; m (Pattern' a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Pattern' a -&gt; m (Pattern' a)) -&gt; Pattern' a -&gt; m (Pattern' a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ConHead
-&gt; ConPatternInfo
-&gt; [Arg (Named NamedName (Pattern' a))]
-&gt; Pattern' a
forall x.
ConHead -&gt; ConPatternInfo -&gt; [NamedArg (Pattern' x)] -&gt; Pattern' x
</span><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-var">ConP</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026563"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="Agda.Syntax.Internal.html#noConPatternInfo"><span class="hs-identifier hs-var">noConPatternInfo</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg (Named NamedName (Pattern' a))]
</span><a href="#local-6989586621682026565"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-360"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621682026570"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026570"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; m (Pattern' a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Pattern' a -&gt; m (Pattern' a)) -&gt; Pattern' a -&gt; m (Pattern' a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PatternInfo -&gt; Literal -&gt; Pattern' a
forall x. PatternInfo -&gt; Literal -&gt; Pattern' x
</span><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-var">LitP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PatOrigin -&gt; [Name] -&gt; PatternInfo
</span><a href="Agda.Syntax.Internal.html#PatternInfo"><span class="hs-identifier hs-var">PatternInfo</span></a></span><span> </span><span class="annot"><span class="annottext">PatOrigin
</span><a href="Agda.Syntax.Internal.html#PatODot"><span class="hs-identifier hs-var">PatODot</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026570"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-361"></span><span>  </span><span id="local-6989586621682026573"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026573"><span class="hs-identifier hs-var">v</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; m (Pattern' a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Pattern' a -&gt; m (Pattern' a)) -&gt; Pattern' a -&gt; m (Pattern' a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Term -&gt; Pattern' a
forall a. Term -&gt; Pattern' a
</span><a href="Agda.Syntax.Internal.html#dotP"><span class="hs-identifier hs-var">dotP</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026573"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-362"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#unDotP"><span class="hs-identifier hs-var">unDotP</span></a></span><span> </span><span id="local-6989586621682026575"><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682026575"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; m (Pattern' a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682026575"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-363"></span><span>
</span><span id="line-364"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-pragma hs-type">isLitP</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span id="local-6989586621682026576"><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-pragma hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026576"><span class="hs-pragma hs-type">a</span></a></span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><span class="hs-pragma hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Agda.Syntax.Literal.html#Literal"><span class="hs-pragma hs-type">Literal</span></a></span><span class="hs-pragma">)</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-365"></span><span id="local-6989586621682026059"><span id="local-6989586621682026060"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-type">isLitP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026059"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026060"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026059"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Agda.Syntax.Literal.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-366"></span><span id="isLitP"><span class="annot"><span class="annottext">isLitP :: forall (m :: * -&gt; *) a.
PureTCM m =&gt;
Pattern' a -&gt; m (Maybe Literal)
</span><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-var hs-var">isLitP</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026616"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026616"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Literal -&gt; m (Maybe Literal)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Maybe Literal -&gt; m (Maybe Literal))
-&gt; Maybe Literal -&gt; m (Maybe Literal)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Maybe Literal
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026616"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-367"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-var">isLitP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682026617"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026617"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; m Term
forall a (m :: * -&gt; *). (Reduce a, MonadReduce m) =&gt; a -&gt; m a
</span><a href="Agda.TypeChecking.Reduce.html#reduce"><span class="hs-identifier hs-var">reduce</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682026617"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">m Term -&gt; (Term -&gt; m (Maybe Literal)) -&gt; m (Maybe Literal)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-368"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621682026618"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026618"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Literal -&gt; m (Maybe Literal)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Maybe Literal -&gt; m (Maybe Literal))
-&gt; Maybe Literal -&gt; m (Maybe Literal)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Maybe Literal
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026618"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-369"></span><span>  </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Literal -&gt; m (Maybe Literal)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Maybe Literal -&gt; m (Maybe Literal))
-&gt; Maybe Literal -&gt; m (Maybe Literal)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Maybe Literal
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-370"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-var">isLitP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682026619"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026619"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682026620"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026620"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-371"></span><span>  </span><span id="local-6989586621682026621"><span class="annot"><a href="#local-6989586621682026621"><span class="hs-identifier hs-var">zero</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">QName -&gt; Maybe QName -&gt; QName
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">QName
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe QName -&gt; QName) -&gt; m (Maybe QName) -&gt; m QName
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">BuiltinId -&gt; m (Maybe QName)
forall (m :: * -&gt; *). HasBuiltins m =&gt; BuiltinId -&gt; m (Maybe QName)
</span><a href="Agda.TypeChecking.Monad.Builtin.html#getBuiltinName%27"><span class="hs-identifier hs-var">getBuiltinName'</span></a></span><span> </span><span class="annot"><span class="annottext">BuiltinId
</span><a href="Agda.Syntax.Builtin.html#builtinZero"><span class="hs-identifier hs-var">builtinZero</span></a></span><span>
</span><span id="line-372"></span><span>  </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#conName"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026619"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">==</span></span><span> </span><span class="annot"><a href="#local-6989586621682026621"><span class="hs-identifier hs-type">zero</span></a></span><span>
</span><span id="line-373"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Agda.Syntax.Literal.html#LitNat"><span class="hs-identifier hs-type">LitNat</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>
</span><span id="line-374"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-375"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-var">isLitP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682026626"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026626"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682026627"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026627"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621682026628"><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026628"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a) -&gt; Bool
forall a. LensHiding a =&gt; a -&gt; Bool
</span><a href="Agda.Syntax.Common.html#visible"><span class="hs-identifier hs-var">visible</span></a></span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026628"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a) -&gt; Bool
forall a. LensRelevance a =&gt; a -&gt; Bool
</span><a href="Agda.Syntax.Common.html#isRelevant"><span class="hs-identifier hs-var">isRelevant</span></a></span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a)
</span><a href="#local-6989586621682026628"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-376"></span><span>  </span><span id="local-6989586621682026632"><span class="annot"><a href="#local-6989586621682026632"><span class="hs-identifier hs-var">suc</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">QName -&gt; Maybe QName -&gt; QName
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">QName
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe QName -&gt; QName) -&gt; m (Maybe QName) -&gt; m QName
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">BuiltinId -&gt; m (Maybe QName)
forall (m :: * -&gt; *). HasBuiltins m =&gt; BuiltinId -&gt; m (Maybe QName)
</span><a href="Agda.TypeChecking.Monad.Builtin.html#getBuiltinName%27"><span class="hs-identifier hs-var">getBuiltinName'</span></a></span><span> </span><span class="annot"><span class="annottext">BuiltinId
</span><a href="Agda.Syntax.Builtin.html#builtinSuc"><span class="hs-identifier hs-var">builtinSuc</span></a></span><span>
</span><span id="line-377"></span><span>  </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#conName"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026626"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">==</span></span><span> </span><span class="annot"><a href="#local-6989586621682026632"><span class="hs-identifier hs-type">suc</span></a></span><span>
</span><span id="line-378"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="hs-identifier hs-type">fmap</span></span><span> </span><span class="annot"><a href="#local-6989586621682026634"><span class="hs-identifier hs-type">inc</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-type">isLitP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-type">namedArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026628"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-379"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-380"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-381"></span><span>    </span><span class="annot"><a href="#local-6989586621682026634"><span class="hs-identifier hs-type">inc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.Syntax.Literal.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Literal.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span>
</span><span id="line-382"></span><span>    </span><span id="local-6989586621682026634"><span class="annot"><span class="annottext">inc :: Literal -&gt; Literal
</span><a href="#local-6989586621682026634"><span class="hs-identifier hs-var hs-var">inc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Literal.html#LitNat"><span class="hs-identifier hs-type">LitNat</span></a></span><span> </span><span id="local-6989586621682026635"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621682026635"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Literal
</span><a href="Agda.Syntax.Literal.html#LitNat"><span class="hs-identifier hs-var">LitNat</span></a></span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; Literal) -&gt; Integer -&gt; Literal
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621682026635"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Integer -&gt; Integer
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-number">1</span></span><span>
</span><span id="line-383"></span><span>    </span><span class="annot"><a href="#local-6989586621682026634"><span class="hs-identifier hs-var">inc</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Literal
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-384"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#isLitP"><span class="hs-identifier hs-var">isLitP</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern' a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Literal -&gt; m (Maybe Literal)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Literal
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-385"></span><span>
</span><span id="line-386"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#unLitP"><span class="hs-pragma hs-type">unLitP</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span id="local-6989586621682026637"><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-pragma hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026637"><span class="hs-pragma hs-type">a</span></a></span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-pragma hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026637"><span class="hs-pragma hs-type">a</span></a></span><span class="hs-pragma">)</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-387"></span><span id="local-6989586621682026065"><span id="local-6989586621682026066"><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#unLitP"><span class="hs-identifier hs-type">unLitP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html#HasBuiltins"><span class="hs-identifier hs-type">HasBuiltins</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026065"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026066"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682026065"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682026066"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-388"></span><span id="unLitP"><span class="annot"><span class="annottext">unLitP :: forall (m :: * -&gt; *) a.
HasBuiltins m =&gt;
Pattern' a -&gt; m (Pattern' a)
</span><a href="Agda.TypeChecking.Coverage.Match.html#unLitP"><span class="hs-identifier hs-var hs-var">unLitP</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span> </span><span id="local-6989586621682026663"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026663"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span id="local-6989586621682026664"><span class="annot"><span class="annottext">l :: Literal
</span><a href="#local-6989586621682026664"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Literal.html#LitNat"><span class="hs-identifier hs-type">LitNat</span></a></span><span> </span><span id="local-6989586621682026665"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621682026665"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621682026665"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Integer -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-389"></span><span> </span><span class="annot"><span class="annottext">m Term -&gt; m Term -&gt; Term -&gt; m Term
forall (m :: * -&gt; *).
Applicative m =&gt;
m Term -&gt; m Term -&gt; Term -&gt; m Term
</span><a href="Agda.TypeChecking.Monad.Builtin.html#constructorForm%27"><span class="hs-identifier hs-var">constructorForm'</span></a></span><span>
</span><span id="line-390"></span><span>   </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term -&gt; Maybe Term -&gt; Term
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Term
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe Term -&gt; Term) -&gt; m (Maybe Term) -&gt; m Term
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">BuiltinId -&gt; m (Maybe Term)
forall (m :: * -&gt; *). HasBuiltins m =&gt; BuiltinId -&gt; m (Maybe Term)
</span><a href="Agda.TypeChecking.Monad.Builtin.html#getBuiltin%27"><span class="hs-identifier hs-var">getBuiltin'</span></a></span><span> </span><span class="annot"><span class="annottext">BuiltinId
</span><a href="Agda.Syntax.Builtin.html#builtinZero"><span class="hs-identifier hs-var">builtinZero</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-391"></span><span>   </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term -&gt; Maybe Term -&gt; Term
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Term
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe Term -&gt; Term) -&gt; m (Maybe Term) -&gt; m Term
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">BuiltinId -&gt; m (Maybe Term)
forall (m :: * -&gt; *). HasBuiltins m =&gt; BuiltinId -&gt; m (Maybe Term)
</span><a href="Agda.TypeChecking.Monad.Builtin.html#getBuiltin%27"><span class="hs-identifier hs-var">getBuiltin'</span></a></span><span> </span><span class="annot"><span class="annottext">BuiltinId
</span><a href="Agda.Syntax.Builtin.html#builtinSuc"><span class="hs-identifier hs-var">builtinSuc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-392"></span><span>   </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; Term
</span><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-var">Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026664"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m Term -&gt; (Term -&gt; m (Pattern' a)) -&gt; m (Pattern' a)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-393"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span id="local-6989586621682026668"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026668"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682026669"><span class="annot"><span class="annottext">ConInfo
</span><a href="#local-6989586621682026669"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span id="local-6989586621682026670"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682026670"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-394"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682026671"><span class="annot"><span class="annottext">toP :: Elim -&gt; Arg (Pattern' a)
</span><a href="#local-6989586621682026671"><span class="hs-identifier hs-var hs-var">toP</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-type">Apply</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621682026674"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682026674"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621682026675"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026675"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ArgInfo -&gt; Pattern' a -&gt; Arg (Pattern' a)
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682026674"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PatternInfo -&gt; Literal -&gt; Pattern' a
forall x. PatternInfo -&gt; Literal -&gt; Pattern' x
</span><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-var">LitP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682026663"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682026675"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-395"></span><span>        </span><span class="annot"><a href="#local-6989586621682026671"><span class="hs-identifier hs-var">toP</span></a></span><span> </span><span class="annot"><span class="annottext">Elim
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Arg (Pattern' a)
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-396"></span><span>        </span><span id="local-6989586621682026676"><span class="annot"><span class="annottext">cpi :: ConPatternInfo
</span><a href="#local-6989586621682026676"><span class="hs-identifier hs-var hs-var">cpi</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="Agda.Syntax.Internal.html#noConPatternInfo"><span class="hs-identifier hs-var">noConPatternInfo</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#conPInfo"><span class="hs-identifier hs-var">conPInfo</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621682026663"><span class="hs-identifier hs-type">info</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-397"></span><span>    </span><span class="annot"><span class="annottext">Pattern' a -&gt; m (Pattern' a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Pattern' a -&gt; m (Pattern' a)) -&gt; Pattern' a -&gt; m (Pattern' a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConPatternInfo -&gt; [NamedArg (Pattern' a)] -&gt; Pattern' a
forall x.
ConHead -&gt; ConPatternInfo -&gt; [NamedArg (Pattern' x)] -&gt; Pattern' x
</span><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-var">ConP</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682026668"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682026676"><span class="hs-identifier hs-var">cpi</span></a></span><span> </span><span class="annot"><span class="annottext">([NamedArg (Pattern' a)] -&gt; Pattern' a)
-&gt; [NamedArg (Pattern' a)] -&gt; Pattern' a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Elim -&gt; NamedArg (Pattern' a))
-&gt; [Elim] -&gt; [NamedArg (Pattern' a)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Pattern' a -&gt; Named_ (Pattern' a))
-&gt; Arg (Pattern' a) -&gt; NamedArg (Pattern' a)
forall a b. (a -&gt; b) -&gt; Arg a -&gt; Arg b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; Named_ (Pattern' a)
forall a name. a -&gt; Named name a
</span><a href="Agda.Syntax.Common.html#unnamed"><span class="hs-identifier hs-var">unnamed</span></a></span><span> </span><span class="annot"><span class="annottext">(Arg (Pattern' a) -&gt; NamedArg (Pattern' a))
-&gt; (Elim -&gt; Arg (Pattern' a)) -&gt; Elim -&gt; NamedArg (Pattern' a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Elim -&gt; Arg (Pattern' a)
</span><a href="#local-6989586621682026671"><span class="hs-identifier hs-var">toP</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682026670"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-398"></span><span>  </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Pattern' a)
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-399"></span><span class="annot"><a href="Agda.TypeChecking.Coverage.Match.html#unLitP"><span class="hs-identifier hs-var">unLitP</span></a></span><span> </span><span id="local-6989586621682026678"><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682026678"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; m (Pattern' a)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682026678"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-400"></span></pre></body></html>