<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Agda.Utils.List</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">Agda</span><ul class="links" id="page-menu"><li><a href="src/Agda.Utils.List.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Agda.Utils.List</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Utility functions for lists.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:-33--33-">(!!)</a> :: <a href="Agda-Utils-CallStack.html#t:HasCallStack" title="Agda.Utils.CallStack">HasCallStack</a> =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a</li><li class="src short"><a href="#v:-33--33--33-">(!!!)</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a</li><li class="src short"><a href="#v:align">align</a> :: [a] -&gt; [b] -&gt; [<a href="https://hackage.haskell.org/package/strict-0.5.1/docs/Data-Strict-These.html#t:These" title="Data.Strict.These">These</a> a b]</li><li class="src short"><a href="#v:allConsecutive">allConsecutive</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:allDuplicates">allDuplicates</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:allEqual">allEqual</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:asum">asum</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m =&gt; [m a] -&gt; m a</li><li class="src short"><a href="#v:asum1">asum1</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m =&gt; m a -&gt; [m a] -&gt; m a</li><li class="src short"><a href="#v:breakAfter">breakAfter</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:breakAfter1">breakAfter1</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; [a] -&gt; (<a href="Agda-Utils-List1.html#t:List1" title="Agda.Utils.List1">List1</a> a, [a])</li><li class="src short"><a href="#v:breakJust">breakJust</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a, (b, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a))</li><li class="src short"><a href="#v:caseList">caseList</a> :: [a] -&gt; b -&gt; (a -&gt; [a] -&gt; b) -&gt; b</li><li class="src short"><a href="#v:caseListM">caseListM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m [a] -&gt; m b -&gt; (a -&gt; [a] -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:chop">chop</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:chopWhen">chopWhen</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:commonPrefix">commonPrefix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a</li><li class="src short"><a href="#v:commonSuffix">commonSuffix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a</li><li class="src short"><a href="#v:distinct">distinct</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:downFrom">downFrom</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a =&gt; a -&gt; [a]</li><li class="src short"><a href="#v:dropCommon">dropCommon</a> :: [a] -&gt; [b] -&gt; (<a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> b)</li><li class="src short"><a href="#v:dropEnd">dropEnd</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a</li><li class="src short"><a href="#v:dropFrom">dropFrom</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="Agda-Utils-List1.html#t:List1" title="Agda.Utils.List1">List1</a> a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:duplicates">duplicates</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:editDistance">editDistance</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:editDistanceSpec">editDistanceSpec</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:fastDistinct">fastDistinct</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:filterAndRest">filterAndRest</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a)</li><li class="src short"><a href="#v:findOverlap">findOverlap</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:findWithIndex">findWithIndex</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:genericElemIndex">genericElemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> i) =&gt; a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> i</li><li class="src short"><a href="#v:hasElem">hasElem</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:headWithDefault">headWithDefault</a> :: a -&gt; [a] -&gt; a</li><li class="src short"><a href="#v:holes">holes</a> :: [a] -&gt; [(a, [a])]</li><li class="src short"><a href="#v:indexWithDefault">indexWithDefault</a> :: a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a</li><li class="src short"><a href="#v:init1">init1</a> :: a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:initLast">initLast</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> ([a], a)</li><li class="src short"><a href="#v:initLast1">initLast1</a> :: a -&gt; [a] -&gt; ([a], a)</li><li class="src short"><a href="#v:initMaybe">initMaybe</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a]</li><li class="src short"><a href="#v:initWithDefault">initWithDefault</a> :: [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:last1">last1</a> :: a -&gt; [a] -&gt; a</li><li class="src short"><a href="#v:last2">last2</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, a)</li><li class="src short"><a href="#v:last2-39-">last2'</a> :: a -&gt; a -&gt; [a] -&gt; (a, a)</li><li class="src short"><a href="#v:lastMaybe">lastMaybe</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a</li><li class="src short"><a href="#v:lastWithDefault">lastWithDefault</a> :: a -&gt; [a] -&gt; a</li><li class="src short"><a href="#v:listCase">listCase</a> :: b -&gt; (a -&gt; [a] -&gt; b) -&gt; [a] -&gt; b</li><li class="src short"><a href="#v:map-39-">map'</a> :: (a -&gt; b) -&gt; [a] -&gt; [b]</li><li class="src short"><a href="#v:mapMaybeAndRest">mapMaybeAndRest</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([b], <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a)</li><li class="src short"><a href="#v:mcons">mcons</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:mergeStrictlyOrderedBy">mergeStrictlyOrderedBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a]</li><li class="src short"><a href="#v:nubAndDuplicatesOn">nubAndDuplicatesOn</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:nubFavouriteOn">nubFavouriteOn</a> :: <span class="keyword">forall</span> a b c. (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> c, <a href="https://hackage.haskell.org/package/hashable-1.5.0.0/docs/Data-Hashable.html#t:Hashable" title="Data.Hashable">Hashable</a> c) =&gt; (a -&gt; b) -&gt; (a -&gt; c) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:nubM">nubM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; m [a]</li><li class="src short"><a href="#v:nubOn">nubOn</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:partitionMaybe">partitionMaybe</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], [b])</li><li class="src short"><a href="#v:snoc">snoc</a> :: [a] -&gt; a -&gt; [a]</li><li class="src short"><a href="#v:sorted">sorted</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:spanEnd">spanEnd</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a)</li><li class="src short"><a href="#v:spanJust">spanJust</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> b, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a)</li><li class="src short"><a href="#v:splitExactlyAt">splitExactlyAt</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> n =&gt; n -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a)</li><li class="src short"><a href="#v:stripPrefixBy">stripPrefixBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a)</li><li class="src short"><a href="#v:stripReversedSuffix">stripReversedSuffix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="Agda-Utils-List.html#t:ReversedSuffix" title="Agda.Utils.List">ReversedSuffix</a> a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a)</li><li class="src short"><a href="#v:stripSuffix">stripSuffix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a)</li><li class="src short"><a href="#v:suffixesSatisfying">suffixesSatisfying</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>]</li><li class="src short"><a href="#v:tailMaybe">tailMaybe</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a]</li><li class="src short"><a href="#v:tailWithDefault">tailWithDefault</a> :: [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:takeExactly">takeExactly</a> :: <span class="keyword">forall</span> a n. <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> n =&gt; a -&gt; n -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:takeWhileJust">takeWhileJust</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> b</li><li class="src short"><a href="#v:uniqOn">uniqOn</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:unzipWith">unzipWith</a> :: (a -&gt; (b, c)) -&gt; [a] -&gt; ([b], [c])</li><li class="src short"><a href="#v:updateAt">updateAt</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (a -&gt; a) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:updateHead">updateHead</a> :: (a -&gt; a) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:updateLast">updateLast</a> :: (a -&gt; a) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:zipWith-39-">zipWith'</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [c]</li><li class="src short"><a href="#v:zipWithKeepRest">zipWithKeepRest</a> :: (a -&gt; b -&gt; b) -&gt; [a] -&gt; [b] -&gt; [b]</li><li class="src short"><span class="keyword">type</span> <a href="#t:Prefix">Prefix</a> a = [a]</li><li class="src short"><span class="keyword">type</span> <a href="#t:ReversedSuffix">ReversedSuffix</a> a = [a]</li><li class="src short"><span class="keyword">data</span> <a href="#t:StrSufSt">StrSufSt</a> a<ul class="subs"><li>= <a href="#v:SSSMismatch">SSSMismatch</a></li><li>| <a href="#v:SSSStrip">SSSStrip</a> (<a href="Agda-Utils-List.html#t:ReversedSuffix" title="Agda.Utils.List">ReversedSuffix</a> a)</li><li>| <a href="#v:SSSResult">SSSResult</a> [a]</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Suffix">Suffix</a> a = [a]</li><li class="src short"><a href="#v:uncons">uncons</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a])</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:-33--33-" class="def">(!!)</a> :: <a href="Agda-Utils-CallStack.html#t:HasCallStack" title="Agda.Utils.CallStack">HasCallStack</a> =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a <a href="src/Agda.Utils.List.html#%21%21" class="link">Source</a> <a href="#v:-33--33-" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:-33--33-" title="Prelude">!!</a></code> that might provide more informative
 error messages if the index is out of bounds.</p><p>Precondition: The index should not be out of bounds.</p></div></div><div class="top"><p class="src"><a id="v:-33--33--33-" class="def">(!!!)</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <a href="src/Agda.Utils.List.html#%21%21%21" class="link">Source</a> <a href="#v:-33--33--33-" class="selflink">#</a></p><div class="doc"><p>Lookup function (safe).
   O(min n index).</p></div></div><div class="top"><p class="src"><a id="v:align" class="def">align</a> :: [a] -&gt; [b] -&gt; [<a href="https://hackage.haskell.org/package/strict-0.5.1/docs/Data-Strict-These.html#t:These" title="Data.Strict.These">These</a> a b] <a href="src/Agda.Utils.List.html#align" class="link">Source</a> <a href="#v:align" class="selflink">#</a></p><div class="doc"><p>Analogous to zip, combines two lists by taking the union using These (strict).</p></div></div><div class="top"><p class="src"><a id="v:allConsecutive" class="def">allConsecutive</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Agda.Utils.List.html#allConsecutive" class="link">Source</a> <a href="#v:allConsecutive" class="selflink">#</a></p><div class="doc"><p>Check whether all consecutive elements of a list satisfy the given relation.
 O(n).</p></div></div><div class="top"><p class="src"><a id="v:allDuplicates" class="def">allDuplicates</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#allDuplicates" class="link">Source</a> <a href="#v:allDuplicates" class="selflink">#</a></p><div class="doc"><p>Remove the first representative for each list element.
   Thus, returns all duplicate copies.
   O(n log n).</p><p><code class="inline-code">allDuplicates xs == sort $ xs \ nub xs</code>.</p></div></div><div class="top"><p class="src"><a id="v:allEqual" class="def">allEqual</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Agda.Utils.List.html#allEqual" class="link">Source</a> <a href="#v:allEqual" class="selflink">#</a></p><div class="doc"><p>Checks if all the elements in the list are equal. Assumes that
   the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code> instance stands for an equivalence relation.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:asum" class="def">asum</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m =&gt; [m a] -&gt; m a <a href="src/Agda.Utils.List.html#asum" class="link">Source</a> <a href="#v:asum" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Foldable.html#v:asum" title="Foldable">asum</a></code> that avoids a final <code><a href="A.html#v:empty" title="A">empty</a></code>.
   It is right-folding just like <code><a href="Foldable.html#v:asum" title="Foldable">asum</a></code>.</p><p>Precondition: the right-unit law holds, i.e. <code class="inline-code">m <a href="|">|</a> A.empty = m</code>.</p></div></div><div class="top"><p class="src"><a id="v:asum1" class="def">asum1</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m =&gt; m a -&gt; [m a] -&gt; m a <a href="src/Agda.Utils.List.html#asum1" class="link">Source</a> <a href="#v:asum1" class="selflink">#</a></p><div class="doc"><p>A right-folding <code><a href="Foldable.html#v:asum" title="Foldable">asum</a></code> for nonempty lists,
   never producing <code><a href="A.html#v:empty" title="A">empty</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:breakAfter" class="def">breakAfter</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="src/Agda.Utils.List.html#breakAfter" class="link">Source</a> <a href="#v:breakAfter" class="selflink">#</a></p><div class="doc"><p>Breaks a list just <em>after</em> an element satisfying the predicate is
   found.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>breakAfter even [1,3,5,2,4,7,8]
</code></strong>([1,3,5,2],[4,7,8])
</pre></div></div><div class="top"><p class="src"><a id="v:breakAfter1" class="def">breakAfter1</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; [a] -&gt; (<a href="Agda-Utils-List1.html#t:List1" title="Agda.Utils.List1">List1</a> a, [a]) <a href="src/Agda.Utils.List.html#breakAfter1" class="link">Source</a> <a href="#v:breakAfter1" class="selflink">#</a></p><div class="doc"><p>Breaks a list just <em>after</em> an element satisfying the predicate is
   found.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>breakAfter1 even 1 [3,5,2,4,7,8]
</code></strong>(1 :| [3,5,2],[4,7,8])
</pre></div></div><div class="top"><p class="src"><a id="v:breakJust" class="def">breakJust</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a, (b, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a)) <a href="src/Agda.Utils.List.html#breakJust" class="link">Source</a> <a href="#v:breakJust" class="selflink">#</a></p><div class="doc"><p>Break a list when the given predicate returns <code class="inline-code">Just b</code>
   and place <code class="inline-code">b</code> as pivot between the prefix
  (where the predicate returns <code class="inline-code">Nothing</code>) and the suffix.</p><p>Crashes when the predicate holds nowhere.</p></div></div><div class="top"><p class="src"><a id="v:caseList" class="def">caseList</a> :: [a] -&gt; b -&gt; (a -&gt; [a] -&gt; b) -&gt; b <a href="src/Agda.Utils.List.html#caseList" class="link">Source</a> <a href="#v:caseList" class="selflink">#</a></p><div class="doc"><p>Case distinction for lists, with list first.
   O(1).</p><p>Cf. <code><a href="Agda-Utils-Null.html#v:ifNull" title="Agda.Utils.Null">ifNull</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:caseListM" class="def">caseListM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m [a] -&gt; m b -&gt; (a -&gt; [a] -&gt; m b) -&gt; m b <a href="src/Agda.Utils.List.html#caseListM" class="link">Source</a> <a href="#v:caseListM" class="selflink">#</a></p><div class="doc"><p>Case distinction for lists, with list first.
   O(1).</p><p>Cf. <code><a href="Agda-Utils-Null.html#v:ifNull" title="Agda.Utils.Null">ifNull</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:chop" class="def">chop</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [[a]] <a href="src/Agda.Utils.List.html#chop" class="link">Source</a> <a href="#v:chop" class="selflink">#</a></p><div class="doc"><p>Chop up a list in chunks of a given length.
 O(n).</p></div></div><div class="top"><p class="src"><a id="v:chopWhen" class="def">chopWhen</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]] <a href="src/Agda.Utils.List.html#chopWhen" class="link">Source</a> <a href="#v:chopWhen" class="selflink">#</a></p><div class="doc"><p>Chop a list at the positions when the predicate holds. Contrary to
   <code class="inline-code">wordsBy</code>, consecutive separator elements will result in an empty segment
   in the result.
   O(n).</p><pre>intercalate [x] (chopWhen (== x) xs) == xs</pre></div></div><div class="top"><p class="src"><a id="v:commonPrefix" class="def">commonPrefix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a <a href="src/Agda.Utils.List.html#commonPrefix" class="link">Source</a> <a href="#v:commonPrefix" class="selflink">#</a></p><div class="doc"><p>Compute the common prefix of two lists.
   O(min n m).</p></div></div><div class="top"><p class="src"><a id="v:commonSuffix" class="def">commonSuffix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a <a href="src/Agda.Utils.List.html#commonSuffix" class="link">Source</a> <a href="#v:commonSuffix" class="selflink">#</a></p><div class="doc"><p>Compute the common suffix of two lists.
   O(n + m).</p></div></div><div class="top"><p class="src"><a id="v:distinct" class="def">distinct</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Agda.Utils.List.html#distinct" class="link">Source</a> <a href="#v:distinct" class="selflink">#</a></p><div class="doc"><p>Check whether all elements in a list are distinct from each other.
   Assumes that the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code> instance stands for an equivalence relation.</p><p>O(n&#178;) in the worst case <code class="inline-code">distinct xs == True</code>.</p></div></div><div class="top"><p class="src"><a id="v:downFrom" class="def">downFrom</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a =&gt; a -&gt; [a] <a href="src/Agda.Utils.List.html#downFrom" class="link">Source</a> <a href="#v:downFrom" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">downFrom n = [n-1,..1,0]</code>.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:dropCommon" class="def">dropCommon</a> :: [a] -&gt; [b] -&gt; (<a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> b) <a href="src/Agda.Utils.List.html#dropCommon" class="link">Source</a> <a href="#v:dropCommon" class="selflink">#</a></p><div class="doc"><p>Drops from both lists simultaneously until one list is empty.
   O(min n m).</p></div></div><div class="top"><p class="src"><a id="v:dropEnd" class="def">dropEnd</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a <a href="src/Agda.Utils.List.html#dropEnd" class="link">Source</a> <a href="#v:dropEnd" class="selflink">#</a></p><div class="doc"><p>Drop from the end of a list.
   O(length).</p><pre>dropEnd n = reverse . drop n . reverse</pre><p>Forces the whole list even for <code class="inline-code">n==0</code>.</p></div></div><div class="top"><p class="src"><a id="v:dropFrom" class="def">dropFrom</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="Agda-Utils-List1.html#t:List1" title="Agda.Utils.List1">List1</a> a -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#dropFrom" class="link">Source</a> <a href="#v:dropFrom" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">dropFrom marker xs</code> drops everything from <code class="inline-code">xs</code>
 starting with (and including) <code class="inline-code">marker</code>.</p><p>If the marker does not appear, the string is returned unchanged.</p><p>The following two properties hold provided <code class="inline-code">marker</code> has no overlap with <code class="inline-code">xs</code>:</p><pre>  dropFrom marker (xs ++ marker ++ ys) == xs
  dropFrom marker xs == xs
</pre></div></div><div class="top"><p class="src"><a id="v:duplicates" class="def">duplicates</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#duplicates" class="link">Source</a> <a href="#v:duplicates" class="selflink">#</a></p><div class="doc"><p>Returns an (arbitrary) representative for each list element
   that occurs more than once.
   O(n log n).</p></div></div><div class="top"><p class="src"><a id="v:editDistance" class="def">editDistance</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Agda.Utils.List.html#editDistance" class="link">Source</a> <a href="#v:editDistance" class="selflink">#</a></p><div class="doc"><p>Implemented using dynamic programming and <code class="inline-code">Data.Array</code>.
   O(n*m).</p></div></div><div class="top"><p class="src"><a id="v:editDistanceSpec" class="def">editDistanceSpec</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Agda.Utils.List.html#editDistanceSpec" class="link">Source</a> <a href="#v:editDistanceSpec" class="selflink">#</a></p><div class="doc"><p>Implemented using tree recursion, don't run me at home!
   O(3^(min n m)).</p></div></div><div class="top"><p class="src"><a id="v:fastDistinct" class="def">fastDistinct</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Agda.Utils.List.html#fastDistinct" class="link">Source</a> <a href="#v:fastDistinct" class="selflink">#</a></p><div class="doc"><p>An optimised version of <code><a href="Agda-Utils-List.html#v:distinct" title="Agda.Utils.List">distinct</a></code>.
   O(n log n).</p><p>Precondition: The list's length must fit in an <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:filterAndRest" class="def">filterAndRest</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a) <a href="src/Agda.Utils.List.html#filterAndRest" class="link">Source</a> <a href="#v:filterAndRest" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:filter" title="GHC.List">filter</a></code>, but additionally return the last partition
   of the list where the predicate is <code class="inline-code">False</code> everywhere.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:findOverlap" class="def">findOverlap</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Agda.Utils.List.html#findOverlap" class="link">Source</a> <a href="#v:findOverlap" class="selflink">#</a></p><div class="doc"><p>Find the longest suffix of the first string <code class="inline-code">xs</code>
   that is a prefix of the second string <code class="inline-code">ys</code>.
   So, basically, find the overlap where the strings can be glued together.
   Returns the index where the overlap starts and the length of the overlap.
   The length of the overlap plus the index is the length of the first string.
   Note that in the worst case, the empty overlap <code class="inline-code">(length xs,0)</code> is returned.</p><p>Worst-case time complexity is quadratic: <code class="inline-code">O(min(n,m)&#178;)</code>
   where <code class="inline-code">n = length xs</code> and <code class="inline-code">m = length ys</code>.</p><p>There might be asymptotically better implementations following
   Knuth-Morris-Pratt (KMP), but for rather short lists this is good enough.</p></div></div><div class="top"><p class="src"><a id="v:findWithIndex" class="def">findWithIndex</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Agda.Utils.List.html#findWithIndex" class="link">Source</a> <a href="#v:findWithIndex" class="selflink">#</a></p><div class="doc"><p>Find an element satisfying a predicate and return it with its index.
   O(n) in the worst case, e.g. <code class="inline-code">findWithIndex f xs = Nothing</code>.</p><p>TODO: more efficient implementation!?</p></div></div><div class="top"><p class="src"><a id="v:genericElemIndex" class="def">genericElemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> i) =&gt; a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> i <a href="src/Agda.Utils.List.html#genericElemIndex" class="link">Source</a> <a href="#v:genericElemIndex" class="selflink">#</a></p><div class="doc"><p>A generalised variant of <code class="inline-code">elemIndex</code>.
 O(n).</p></div></div><div class="top"><p class="src"><a id="v:hasElem" class="def">hasElem</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Agda.Utils.List.html#hasElem" class="link">Source</a> <a href="#v:hasElem" class="selflink">#</a></p><div class="doc"><p>Check membership for the same list often.
   Use partially applied to create membership predicate
   <code class="inline-code">hasElem xs :: a -&gt; Bool</code>.</p><ul><li>First time: <code class="inline-code">O(n log n)</code> in the worst case.</li><li>Subsequently: <code class="inline-code">O(log n)</code>.</li></ul><p>Specification: <code class="inline-code">hasElem xs == (<code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Foldable.html#v:elem" title="Data.Foldable">elem</a></code> xs)</code>.</p></div></div><div class="top"><p class="src"><a id="v:headWithDefault" class="def">headWithDefault</a> :: a -&gt; [a] -&gt; a <a href="src/Agda.Utils.List.html#headWithDefault" class="link">Source</a> <a href="#v:headWithDefault" class="selflink">#</a></p><div class="doc"><p>Head function (safe). Returns a default value on empty lists.
   O(1).</p><pre>headWithDefault 42 []      = 42
headWithDefault 42 [1,2,3] = 1</pre></div></div><div class="top"><p class="src"><a id="v:holes" class="def">holes</a> :: [a] -&gt; [(a, [a])] <a href="src/Agda.Utils.List.html#holes" class="link">Source</a> <a href="#v:holes" class="selflink">#</a></p><div class="doc"><p>All ways of removing one element from a list.
   O(n&#178;).</p></div></div><div class="top"><p class="src"><a id="v:indexWithDefault" class="def">indexWithDefault</a> :: a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a <a href="src/Agda.Utils.List.html#indexWithDefault" class="link">Source</a> <a href="#v:indexWithDefault" class="selflink">#</a></p><div class="doc"><p>Lookup function with default value for index out of range.
   O(min n index).</p><p>The name is chosen akin to <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-List.html#v:genericIndex" title="Data.List">genericIndex</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:init1" class="def">init1</a> :: a -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#init1" class="link">Source</a> <a href="#v:init1" class="selflink">#</a></p><div class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:init" title="GHC.List">init</a></code> of non-empty list, safe.
   O(n).
   <code class="inline-code">init1 a as = init (a:as)</code></p></div></div><div class="top"><p class="src"><a id="v:initLast" class="def">initLast</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> ([a], a) <a href="src/Agda.Utils.List.html#initLast" class="link">Source</a> <a href="#v:initLast" class="selflink">#</a></p><div class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:init" title="GHC.List">init</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:last" title="GHC.List">last</a></code> in one go, safe.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:initLast1" class="def">initLast1</a> :: a -&gt; [a] -&gt; ([a], a) <a href="src/Agda.Utils.List.html#initLast1" class="link">Source</a> <a href="#v:initLast1" class="selflink">#</a></p><div class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:init" title="GHC.List">init</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:last" title="GHC.List">last</a></code> of non-empty list, safe.
   O(n).
   <code class="inline-code">initLast1 a as = (init (a:as), last (a:as)</code></p></div></div><div class="top"><p class="src"><a id="v:initMaybe" class="def">initMaybe</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a] <a href="src/Agda.Utils.List.html#initMaybe" class="link">Source</a> <a href="#v:initMaybe" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">init</code>, safe.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:initWithDefault" class="def">initWithDefault</a> :: [a] -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#initWithDefault" class="link">Source</a> <a href="#v:initWithDefault" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">init</code>, safe.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:last1" class="def">last1</a> :: a -&gt; [a] -&gt; a <a href="src/Agda.Utils.List.html#last1" class="link">Source</a> <a href="#v:last1" class="selflink">#</a></p><div class="doc"><p>Last element of non-empty list (safe).
   O(n).
   <code class="inline-code">last1 a as = last (a : as)</code></p></div></div><div class="top"><p class="src"><a id="v:last2" class="def">last2</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, a) <a href="src/Agda.Utils.List.html#last2" class="link">Source</a> <a href="#v:last2" class="selflink">#</a></p><div class="doc"><p>Last two elements (safe).
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:last2-39-" class="def">last2'</a> :: a -&gt; a -&gt; [a] -&gt; (a, a) <a href="src/Agda.Utils.List.html#last2%27" class="link">Source</a> <a href="#v:last2-39-" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">last2' x y zs</code> computes the last two elements of <code class="inline-code">x:y:zs</code>.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:lastMaybe" class="def">lastMaybe</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a <a href="src/Agda.Utils.List.html#lastMaybe" class="link">Source</a> <a href="#v:lastMaybe" class="selflink">#</a></p><div class="doc"><p>Last element (safe).
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:lastWithDefault" class="def">lastWithDefault</a> :: a -&gt; [a] -&gt; a <a href="src/Agda.Utils.List.html#lastWithDefault" class="link">Source</a> <a href="#v:lastWithDefault" class="selflink">#</a></p><div class="doc"><p>Last element (safe).  Returns a default list on empty lists.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:listCase" class="def">listCase</a> :: b -&gt; (a -&gt; [a] -&gt; b) -&gt; [a] -&gt; b <a href="src/Agda.Utils.List.html#listCase" class="link">Source</a> <a href="#v:listCase" class="selflink">#</a></p><div class="doc"><p>Case distinction for lists, with list last.
   O(1).</p></div></div><div class="top"><p class="src"><a id="v:map-39-" class="def">map'</a> :: (a -&gt; b) -&gt; [a] -&gt; [b] <a href="src/Agda.Utils.List.html#map%27" class="link">Source</a> <a href="#v:map-39-" class="selflink">#</a></p><div class="doc"><p>Strict map.</p></div></div><div class="top"><p class="src"><a id="v:mapMaybeAndRest" class="def">mapMaybeAndRest</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([b], <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a) <a href="src/Agda.Utils.List.html#mapMaybeAndRest" class="link">Source</a> <a href="#v:mapMaybeAndRest" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:mapMaybe" title="Data.Maybe">mapMaybe</a></code>, but additionally return the last partition
   of the list where the function always returns <code class="inline-code">Nothing</code>.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:mcons" class="def">mcons</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#mcons" class="link">Source</a> <a href="#v:mcons" class="selflink">#</a></p><div class="doc"><p>Maybe cons.
   O(1).
   <code class="inline-code">mcons ma as = maybeToList ma ++ as</code></p></div></div><div class="top"><p class="src"><a id="v:mergeStrictlyOrderedBy" class="def">mergeStrictlyOrderedBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a] <a href="src/Agda.Utils.List.html#mergeStrictlyOrderedBy" class="link">Source</a> <a href="#v:mergeStrictlyOrderedBy" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:nubAndDuplicatesOn" class="def">nubAndDuplicatesOn</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; ([a], [a]) <a href="src/Agda.Utils.List.html#nubAndDuplicatesOn" class="link">Source</a> <a href="#v:nubAndDuplicatesOn" class="selflink">#</a></p><div class="doc"><p>Partition a list into first and later occurrences of elements
   (modulo some quotient given by a representation function).</p><p>Time: O(n log n).</p><p>Specification:</p><pre>nubAndDuplicatesOn f xs = (ys, xs List.\\ ys)
  where ys = nubOn f xs</pre></div></div><div class="top"><p class="src"><a id="v:nubFavouriteOn" class="def">nubFavouriteOn</a> <a href="src/Agda.Utils.List.html#nubFavouriteOn" class="link">Source</a> <a href="#v:nubFavouriteOn" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> a b c. (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> c, <a href="https://hackage.haskell.org/package/hashable-1.5.0.0/docs/Data-Hashable.html#t:Hashable" title="Data.Hashable">Hashable</a> c)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; b)</td><td class="doc"><p>The values returned by this function are used to determine
 which element from a group of equal elements that is returned:
 the smallest one is chosen (and if two elements are equally
 small, then the first one is chosen).</p></td></tr><tr><td class="src">-&gt; (a -&gt; c)</td><td class="doc"><p>Two elements are treated as equal if this function returns
 the same value for both elements.</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; [a]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A variant of <code><a href="Agda-Utils-List.html#v:nubOn" title="Agda.Utils.List">nubOn</a></code> that is parametrised by a function that is
 used to select which element from a group of equal elements that is
 returned. The returned elements keep the order that they had in the
 input list.</p><p>Precondition: The length of the input list must be at most
 <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Enum.html#v:maxBound" title="Data.Enum">maxBound</a></code> :: <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code></code>.</p></div></div><div class="top"><p class="src"><a id="v:nubM" class="def">nubM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; m [a] <a href="src/Agda.Utils.List.html#nubM" class="link">Source</a> <a href="#v:nubM" class="selflink">#</a></p><div class="doc"><p>Non-efficient, monadic <code class="inline-code">nub</code>.
 O(n&#178;).</p></div></div><div class="top"><p class="src"><a id="v:nubOn" class="def">nubOn</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#nubOn" class="link">Source</a> <a href="#v:nubOn" class="selflink">#</a></p><div class="doc"><p>Efficient variant of <code class="inline-code">nubBy</code> for lists, using a set to store already seen elements.
 O(n log n)</p><p>Specification:</p><pre>nubOn f xs == 'nubBy' ((==) `'on'` f) xs.</pre></div></div><div class="top"><p class="src"><a id="v:partitionMaybe" class="def">partitionMaybe</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], [b]) <a href="src/Agda.Utils.List.html#partitionMaybe" class="link">Source</a> <a href="#v:partitionMaybe" class="selflink">#</a></p><div class="doc"><p>Partition a list into <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>s and <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>s.
   O(n).</p><pre>partitionMaybe f = partitionEithers . map ( a -&gt; maybe (Left a) Right (f a))</pre><p>Note: <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:mapMaybe" title="Data.Maybe">mapMaybe</a></code> f = snd . partitionMaybe f</code>.</p></div></div><div class="top"><p class="src"><a id="v:snoc" class="def">snoc</a> :: [a] -&gt; a -&gt; [a] <a href="src/Agda.Utils.List.html#snoc" class="link">Source</a> <a href="#v:snoc" class="selflink">#</a></p><div class="doc"><p>Append a single element at the end.
   Time: O(length); use only on small lists.</p></div></div><div class="top"><p class="src"><a id="v:sorted" class="def">sorted</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Agda.Utils.List.html#sorted" class="link">Source</a> <a href="#v:sorted" class="selflink">#</a></p><div class="doc"><p>Check whether a list is sorted.
 O(n).</p><p>Assumes that the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance implements a partial order.</p></div></div><div class="top"><p class="src"><a id="v:spanEnd" class="def">spanEnd</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a) <a href="src/Agda.Utils.List.html#spanEnd" class="link">Source</a> <a href="#v:spanEnd" class="selflink">#</a></p><div class="doc"><p>Split off the largest suffix whose elements satisfy a predicate.
   O(n).</p><p><code class="inline-code">spanEnd p xs = (ys, zs)</code>
   where <code class="inline-code">xs = ys ++ zs</code>
   and <code class="inline-code">all p zs</code>
   and <code class="inline-code">maybe True (not . p) (lastMaybe yz)</code>.</p></div></div><div class="top"><p class="src"><a id="v:spanJust" class="def">spanJust</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> b, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a) <a href="src/Agda.Utils.List.html#spanJust" class="link">Source</a> <a href="#v:spanJust" class="selflink">#</a></p><div class="doc"><p>A generalized version of <code class="inline-code">span</code>.
   <code class="inline-code">O(length . fst . spanJust f)</code>.</p></div></div><div class="top"><p class="src"><a id="v:splitExactlyAt" class="def">splitExactlyAt</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> n =&gt; n -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a, <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a) <a href="src/Agda.Utils.List.html#splitExactlyAt" class="link">Source</a> <a href="#v:splitExactlyAt" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">splitExactlyAt n xs = Just (ys, zs)</code> iff <code class="inline-code">xs = ys ++ zs</code>
   and <code class="inline-code">genericLength ys = n</code>.</p></div></div><div class="top"><p class="src"><a id="v:stripPrefixBy" class="def">stripPrefixBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a) <a href="src/Agda.Utils.List.html#stripPrefixBy" class="link">Source</a> <a href="#v:stripPrefixBy" class="selflink">#</a></p><div class="doc"><p>Check if a list has a given prefix. If so, return the list
   minus the prefix.
   O(length prefix).</p></div></div><div class="top"><p class="src"><a id="v:stripReversedSuffix" class="def">stripReversedSuffix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="Agda-Utils-List.html#t:ReversedSuffix" title="Agda.Utils.List">ReversedSuffix</a> a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a) <a href="src/Agda.Utils.List.html#stripReversedSuffix" class="link">Source</a> <a href="#v:stripReversedSuffix" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">stripReversedSuffix rsuf xs = Just pre</code> iff <code class="inline-code">xs = pre ++ reverse suf</code>.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:stripSuffix" class="def">stripSuffix</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="Agda-Utils-List.html#t:Suffix" title="Agda.Utils.List">Suffix</a> a -&gt; [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> a) <a href="src/Agda.Utils.List.html#stripSuffix" class="link">Source</a> <a href="#v:stripSuffix" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">stripSuffix suf xs = Just pre</code> iff <code class="inline-code">xs = pre ++ suf</code>.
 O(n).</p></div></div><div class="top"><p class="src"><a id="v:suffixesSatisfying" class="def">suffixesSatisfying</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>] <a href="src/Agda.Utils.List.html#suffixesSatisfying" class="link">Source</a> <a href="#v:suffixesSatisfying" class="selflink">#</a></p><div class="doc"><p>Returns a list with one boolean for each non-empty suffix of the
 list, starting with the longest suffix (the entire list). Each
 boolean is <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> exactly when every element in the corresponding
 suffix satisfies the predicate.</p><p>An example:
 <code class="inline-code">
  <code><a href="Agda-Utils-List.html#v:suffixesSatisfying" title="Agda.Utils.List">suffixesSatisfying</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Char.html#v:isLower" title="Data.Char">isLower</a></code> <a href="AbCde.html">AbCde</a> =
  [False, False, False, True, True]
 </code></p><p>For total predicates <code class="inline-code">p</code> and finite and total lists <code class="inline-code">xs</code> the
 following holds:
 <code class="inline-code">
  <code><a href="Agda-Utils-List.html#v:suffixesSatisfying" title="Agda.Utils.List">suffixesSatisfying</a></code> p xs = <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:map" title="GHC.List">map</a></code> (<code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Foldable.html#v:all" title="Data.Foldable">all</a></code> p) (<code><a href="List.html#v:init" title="List">init</a></code> (<code><a href="List.html#v:tails" title="List">tails</a></code> xs))
 </code></p></div></div><div class="top"><p class="src"><a id="v:tailMaybe" class="def">tailMaybe</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a] <a href="src/Agda.Utils.List.html#tailMaybe" class="link">Source</a> <a href="#v:tailMaybe" class="selflink">#</a></p><div class="doc"><p>Tail function (safe).
   O(1).</p></div></div><div class="top"><p class="src"><a id="v:tailWithDefault" class="def">tailWithDefault</a> :: [a] -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#tailWithDefault" class="link">Source</a> <a href="#v:tailWithDefault" class="selflink">#</a></p><div class="doc"><p>Tail function (safe).  Returns a default list on empty lists.
   O(1).</p></div></div><div class="top"><p class="src"><a id="v:takeExactly" class="def">takeExactly</a> :: <span class="keyword">forall</span> a n. <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> n =&gt; a -&gt; n -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#takeExactly" class="link">Source</a> <a href="#v:takeExactly" class="selflink">#</a></p><div class="doc"><pre>takeExactly a n as == take n (as ++ repeat a)</pre></div></div><div class="top"><p class="src"><a id="v:takeWhileJust" class="def">takeWhileJust</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; <a href="Agda-Utils-List.html#t:Prefix" title="Agda.Utils.List">Prefix</a> b <a href="src/Agda.Utils.List.html#takeWhileJust" class="link">Source</a> <a href="#v:takeWhileJust" class="selflink">#</a></p><div class="doc"><p>A generalized version of <code class="inline-code">takeWhile</code>.
   (Cf. <code class="inline-code">mapMaybe</code> vs. <code class="inline-code">filter</code>).
   @O(length . takeWhileJust f).</p><p><code class="inline-code">takeWhileJust f = fst . spanJust f</code>.</p></div></div><div class="top"><p class="src"><a id="v:uniqOn" class="def">uniqOn</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#uniqOn" class="link">Source</a> <a href="#v:uniqOn" class="selflink">#</a></p><div class="doc"><p>Efficient variant of <code class="inline-code">nubBy</code> for finite lists.
 O(n log n).</p><pre>uniqOn f == 'List.sortBy' (compare `'on'` f) . 'nubBy' ((==) `'on'` f)</pre><p>If there are several elements with the same <code class="inline-code">f</code>-representative,
 the first of these is kept.</p></div></div><div class="top"><p class="src"><a id="v:unzipWith" class="def">unzipWith</a> :: (a -&gt; (b, c)) -&gt; [a] -&gt; ([b], [c]) <a href="src/Agda.Utils.List.html#unzipWith" class="link">Source</a> <a href="#v:unzipWith" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:updateAt" class="def">updateAt</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (a -&gt; a) -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#updateAt" class="link">Source</a> <a href="#v:updateAt" class="selflink">#</a></p><div class="doc"><p>Update nth element of a list, if it exists.
   <code class="inline-code">O(min index n)</code>.</p><p>Precondition: the index is &gt;= 0.</p></div></div><div class="top"><p class="src"><a id="v:updateHead" class="def">updateHead</a> :: (a -&gt; a) -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#updateHead" class="link">Source</a> <a href="#v:updateHead" class="selflink">#</a></p><div class="doc"><p>Update the first element of a list, if it exists.
   O(1).</p></div></div><div class="top"><p class="src"><a id="v:updateLast" class="def">updateLast</a> :: (a -&gt; a) -&gt; [a] -&gt; [a] <a href="src/Agda.Utils.List.html#updateLast" class="link">Source</a> <a href="#v:updateLast" class="selflink">#</a></p><div class="doc"><p>Update the last element of a list, if it exists.
   O(n).</p></div></div><div class="top"><p class="src"><a id="v:zipWith-39-" class="def">zipWith'</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [c] <a href="src/Agda.Utils.List.html#zipWith%27" class="link">Source</a> <a href="#v:zipWith-39-" class="selflink">#</a></p><div class="doc"><p>Requires both lists to have the same length.
   O(n).</p><p>Otherwise, <code class="inline-code">Nothing</code> is returned.</p></div></div><div class="top"><p class="src"><a id="v:zipWithKeepRest" class="def">zipWithKeepRest</a> :: (a -&gt; b -&gt; b) -&gt; [a] -&gt; [b] -&gt; [b] <a href="src/Agda.Utils.List.html#zipWithKeepRest" class="link">Source</a> <a href="#v:zipWithKeepRest" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:zipWith" title="GHC.List">zipWith</a></code> but keep the rest of the second list as-is
   (in case the second list is longer).
 O(n).</p><pre>  zipWithKeepRest f as bs == zipWith f as bs ++ drop (length as) bs
</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Prefix" class="def">Prefix</a> a <a href="src/Agda.Utils.List.html#Prefix" class="link">Source</a> <a href="#t:Prefix" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">&nbsp;= [a]</td><td class="doc"><p>The list before the split point.</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ReversedSuffix" class="def">ReversedSuffix</a> a = [a] <a href="src/Agda.Utils.List.html#ReversedSuffix" class="link">Source</a> <a href="#t:ReversedSuffix" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:StrSufSt" class="def">StrSufSt</a> a <a href="src/Agda.Utils.List.html#StrSufSt" class="link">Source</a> <a href="#t:StrSufSt" class="selflink">#</a></p><div class="doc"><p>Internal state for stripping suffix.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:SSSMismatch" class="def">SSSMismatch</a></td><td class="doc"><p>Error.</p></td></tr><tr><td class="src"><a id="v:SSSStrip" class="def">SSSStrip</a> (<a href="Agda-Utils-List.html#t:ReversedSuffix" title="Agda.Utils.List">ReversedSuffix</a> a)</td><td class="doc"><p>&quot;Negative string&quot; to remove from end. List may be empty.</p></td></tr><tr><td class="src"><a id="v:SSSResult" class="def">SSSResult</a> [a]</td><td class="doc"><p>&quot;Positive string&quot; (result). Non-empty list.</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Suffix" class="def">Suffix</a> a <a href="src/Agda.Utils.List.html#Suffix" class="link">Source</a> <a href="#t:Suffix" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">&nbsp;= [a]</td><td class="doc"><p>The list after the split point.</p></td></tr></table></div></div><div class="top"><p class="src"><a id="v:uncons" class="def">uncons</a> :: [a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a]) <a href="#v:uncons" class="selflink">#</a></p><div class="doc"><p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Decompose a list into its <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:head" title="GHC.List">head</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:tail" title="GHC.List">tail</a></code>.</p><ul><li>If the list is empty, returns <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</li><li>If the list is non-empty, returns <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> (x, xs)</code>,
 where <code class="inline-code">x</code> is the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:head" title="GHC.List">head</a></code> of the list and <code class="inline-code">xs</code> its <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-List.html#v:tail" title="GHC.List">tail</a></code>.</li></ul><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:uncons0">Examples</h4><details id="ch:uncons0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>uncons []
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>uncons [1]
</code></strong>Just (1,[])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>uncons [1, 2, 3]
</code></strong>Just (1,[2,3])
</pre></details><p><em>Since: base-4.8.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>