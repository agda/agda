<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Agda.Syntax.Parser.Lexer</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">Agda</span><ul class="links" id="page-menu"><li><a href="src/Agda.Syntax.Parser.Lexer.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Agda.Syntax.Parser.Lexer</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">The main function</a></li><li><a href="#g:2">Lex states</a></li><li><a href="#g:3">Alex generated functions</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The lexer is generated by Alex (<a href="http://www.haskell.org/alex">http://www.haskell.org/alex</a>) and is an
    adaptation of GHC's lexer. The main lexing function <code><a href="Agda-Syntax-Parser-Lexer.html#v:lexer" title="Agda.Syntax.Parser.Lexer">lexer</a></code> is called by
    the <a href="Agda-Syntax-Parser-Parser.html">Agda.Syntax.Parser.Parser</a> to get the next token from the input.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:lexer">lexer</a> :: (<a href="Agda-Syntax-Parser-Tokens.html#t:Token" title="Agda.Syntax.Parser.Tokens">Token</a> -&gt; <a href="Agda-Syntax-Parser-Monad.html#t:Parser" title="Agda.Syntax.Parser.Monad">Parser</a> a) -&gt; <a href="Agda-Syntax-Parser-Monad.html#t:Parser" title="Agda.Syntax.Parser.Monad">Parser</a> a</li><li class="src short"><a href="#v:normal">normal</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a></li><li class="src short"><a href="#v:code">code</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:layout">layout</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a></li><li class="src short"><a href="#v:empty_layout">empty_layout</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a></li><li class="src short"><a href="#v:bol">bol</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a></li><li class="src short"><a href="#v:imp_dir">imp_dir</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:AlexReturn">AlexReturn</a> a<ul class="subs"><li>= <a href="#v:AlexEOF">AlexEOF</a></li><li>| <a href="#v:AlexError">AlexError</a> !<a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a></li><li>| <a href="#v:AlexSkip">AlexSkip</a> !<a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a> !<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li>| <a href="#v:AlexToken">AlexToken</a> !<a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a> !<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> a</li></ul></li><li class="src short"><a href="#v:alexScanUser">alexScanUser</a> :: ([<a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a>], <a href="Agda-Syntax-Parser-Monad.html#t:ParseFlags" title="Agda.Syntax.Parser.Monad">ParseFlags</a>) -&gt; <a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Agda-Syntax-Parser-Lexer.html#t:AlexReturn" title="Agda.Syntax.Parser.Lexer">AlexReturn</a> (<a href="Agda-Syntax-Parser-Alex.html#t:LexAction" title="Agda.Syntax.Parser.Alex">LexAction</a> <a href="Agda-Syntax-Parser-Tokens.html#t:Token" title="Agda.Syntax.Parser.Tokens">Token</a>)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>The main function</h1></a><div class="top"><p class="src"><a id="v:lexer" class="def">lexer</a> :: (<a href="Agda-Syntax-Parser-Tokens.html#t:Token" title="Agda.Syntax.Parser.Tokens">Token</a> -&gt; <a href="Agda-Syntax-Parser-Monad.html#t:Parser" title="Agda.Syntax.Parser.Monad">Parser</a> a) -&gt; <a href="Agda-Syntax-Parser-Monad.html#t:Parser" title="Agda.Syntax.Parser.Monad">Parser</a> a <a href="src/Agda.Syntax.Parser.Lexer.html#lexer" class="link">Source</a> <a href="#v:lexer" class="selflink">#</a></p><div class="doc"><p>Return the next token. This is the function used by Happy in the parser.</p><pre>lexer k = <code><a href="Agda-Syntax-Parser-LexActions.html#v:lexToken" title="Agda.Syntax.Parser.LexActions">lexToken</a></code> &gt;&gt;= k</pre></div></div><a href="#g:2" id="g:2"><h1>Lex states</h1></a><div class="top"><p class="src"><a id="v:normal" class="def">normal</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a> <a href="src/Agda.Syntax.Parser.Lexer.html#normal" class="link">Source</a> <a href="#v:normal" class="selflink">#</a></p><div class="doc"><p>This is the initial state for parsing a regular, non-literate file.</p></div></div><div class="top"><p class="src"><a id="v:code" class="def">code</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Agda.Syntax.Parser.Lexer.html#code" class="link">Source</a> <a href="#v:code" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:layout" class="def">layout</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a> <a href="src/Agda.Syntax.Parser.Lexer.html#layout" class="link">Source</a> <a href="#v:layout" class="selflink">#</a></p><div class="doc"><p>The layout state. Entered when we see a layout keyword (<code><a href="Agda-Syntax-Parser-LexActions.html#v:withLayout" title="Agda.Syntax.Parser.LexActions">withLayout</a></code>) and
    exited at the next token (<code><a href="Agda-Syntax-Parser-Layout.html#v:newLayoutBlock" title="Agda.Syntax.Parser.Layout">newLayoutBlock</a></code>).</p></div></div><div class="top"><p class="src"><a id="v:empty_layout" class="def">empty_layout</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a> <a href="src/Agda.Syntax.Parser.Lexer.html#empty_layout" class="link">Source</a> <a href="#v:empty_layout" class="selflink">#</a></p><div class="doc"><p>We enter this state from <code><a href="Agda-Syntax-Parser-Layout.html#v:newLayoutBlock" title="Agda.Syntax.Parser.Layout">newLayoutBlock</a></code> when the token following a
    layout keyword is to the left of (or at the same column as) the current
    layout context. Example:</p><pre>data Empty : Set where
foo : Empty -&gt; Nat</pre><p>Here the second line is not part of the <code class="inline-code">where</code> clause since it is has the
    same indentation as the <code class="inline-code">data</code> definition. What we have to do is insert an
    empty layout block <code class="inline-code">{}</code> after the <code class="inline-code">where</code>. The only thing that can happen
    in this state is that <code><a href="Agda-Syntax-Parser-Layout.html#v:emptyLayout" title="Agda.Syntax.Parser.Layout">emptyLayout</a></code> is executed, generating the closing
    brace. The open brace is generated when entering by <code><a href="Agda-Syntax-Parser-Layout.html#v:newLayoutBlock" title="Agda.Syntax.Parser.Layout">newLayoutBlock</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:bol" class="def">bol</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a> <a href="src/Agda.Syntax.Parser.Lexer.html#bol" class="link">Source</a> <a href="#v:bol" class="selflink">#</a></p><div class="doc"><p>This state is entered at the beginning of each line. You can't lex
   anything in this state, and to exit you have to check the layout rule.
   Done with <code><a href="Agda-Syntax-Parser-Layout.html#v:offsideRule" title="Agda.Syntax.Parser.Layout">offsideRule</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:imp_dir" class="def">imp_dir</a> :: <a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a> <a href="src/Agda.Syntax.Parser.Lexer.html#imp_dir" class="link">Source</a> <a href="#v:imp_dir" class="selflink">#</a></p><div class="doc"><p>This state can only be entered by the parser. In this state you can only
   lex the keywords <code class="inline-code">using</code>, <code class="inline-code">hiding</code>, <code class="inline-code">renaming</code> and <code class="inline-code">to</code>. Moreover they are
   only keywords in this particular state. The lexer will never enter this
   state by itself, that has to be done in the parser.</p></div></div><a href="#g:3" id="g:3"><h1>Alex generated functions</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:AlexReturn" class="def">AlexReturn</a> a <a href="src/Agda.Syntax.Parser.Lexer.html#AlexReturn" class="link">Source</a> <a href="#t:AlexReturn" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:AlexEOF" class="def">AlexEOF</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:AlexError" class="def">AlexError</a> !<a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:AlexSkip" class="def">AlexSkip</a> !<a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a> !<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:AlexToken" class="def">AlexToken</a> !<a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a> !<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a id="v:alexScanUser" class="def">alexScanUser</a> :: ([<a href="Agda-Syntax-Parser-Monad.html#t:LexState" title="Agda.Syntax.Parser.Monad">LexState</a>], <a href="Agda-Syntax-Parser-Monad.html#t:ParseFlags" title="Agda.Syntax.Parser.Monad">ParseFlags</a>) -&gt; <a href="Agda-Syntax-Parser-Alex.html#t:AlexInput" title="Agda.Syntax.Parser.Alex">AlexInput</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Agda-Syntax-Parser-Lexer.html#t:AlexReturn" title="Agda.Syntax.Parser.Lexer">AlexReturn</a> (<a href="Agda-Syntax-Parser-Alex.html#t:LexAction" title="Agda.Syntax.Parser.Alex">LexAction</a> <a href="Agda-Syntax-Parser-Tokens.html#t:Token" title="Agda.Syntax.Parser.Tokens">Token</a>) <a href="src/Agda.Syntax.Parser.Lexer.html#alexScanUser" class="link">Source</a> <a href="#v:alexScanUser" class="selflink">#</a></p><div class="doc"><p>This is the main lexing function generated by Alex.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>