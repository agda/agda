<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Agda.Utils.Function</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">Agda</span><ul class="links" id="page-menu"><li><a href="src/Agda.Utils.Function.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Agda.Utils.Function</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:applyUnless">applyUnless</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyUnlessIts">applyUnlessIts</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; (a -&gt; b) -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyUnlessM">applyUnlessM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:applyWhen">applyWhen</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyWhenIts">applyWhenIts</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; (a -&gt; b) -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyWhenJust">applyWhenJust</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (b -&gt; a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyWhenM">applyWhenM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:applyWhenNothing">applyWhenNothing</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:iterWhile">iterWhile</a> :: (b -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; (b, a)) -&gt; a -&gt; [(b, a)]</li><li class="src short"><a href="#v:iterate-39-">iterate'</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:iterateUntil">iterateUntil</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:iterateUntilM">iterateUntilM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; m a) -&gt; a -&gt; m a</li><li class="src short"><a href="#v:repeatWhile">repeatWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a</li><li class="src short"><a href="#v:repeatWhileM">repeatWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a</li><li class="src short"><a href="#v:trampoline">trampoline</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a) -&gt; a -&gt; b</li><li class="src short"><a href="#v:trampolineM">trampolineM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a)) -&gt; a -&gt; m b</li><li class="src short"><a href="#v:trampolineWhile">trampolineWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a</li><li class="src short"><a href="#v:trampolineWhileM">trampolineWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a</li><li class="src short"><a href="#v:on">on</a> :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:applyUnless" class="def">applyUnless</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyUnless" class="link">Source</a> <a href="#v:applyUnless" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">applyUnless b f a</code> applies <code class="inline-code">f</code> to <code class="inline-code">a</code> unless <code class="inline-code">b</code>.</p></div></div><div class="top"><p class="src"><a id="v:applyUnlessIts" class="def">applyUnlessIts</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; (a -&gt; b) -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyUnlessIts" class="link">Source</a> <a href="#v:applyUnlessIts" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">applyUnlessIts p f a</code> applies <code class="inline-code">f</code> to <code class="inline-code">a</code> unless <code class="inline-code">p a</code>.</p></div></div><div class="top"><p class="src"><a id="v:applyUnlessM" class="def">applyUnlessM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a <a href="src/Agda.Utils.Function.html#applyUnlessM" class="link">Source</a> <a href="#v:applyUnlessM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code class="inline-code">applyUnless</code></p></div></div><div class="top"><p class="src"><a id="v:applyWhen" class="def">applyWhen</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyWhen" class="link">Source</a> <a href="#v:applyWhen" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">applyWhen b f a</code> applies <code class="inline-code">f</code> to <code class="inline-code">a</code> when <code class="inline-code">b</code>.</p></div></div><div class="top"><p class="src"><a id="v:applyWhenIts" class="def">applyWhenIts</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; (a -&gt; b) -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyWhenIts" class="link">Source</a> <a href="#v:applyWhenIts" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">applyWhenIts p f a</code> applies <code class="inline-code">f</code> to <code class="inline-code">a</code> when <code class="inline-code">p a</code>.</p></div></div><div class="top"><p class="src"><a id="v:applyWhenJust" class="def">applyWhenJust</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (b -&gt; a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyWhenJust" class="link">Source</a> <a href="#v:applyWhenJust" class="selflink">#</a></p><div class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> version of <code><a href="Agda-Utils-Function.html#v:applyWhen" title="Agda.Utils.Function">applyWhen</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:applyWhenM" class="def">applyWhenM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a <a href="src/Agda.Utils.Function.html#applyWhenM" class="link">Source</a> <a href="#v:applyWhenM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code class="inline-code">applyWhen</code></p></div></div><div class="top"><p class="src"><a id="v:applyWhenNothing" class="def">applyWhenNothing</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyWhenNothing" class="link">Source</a> <a href="#v:applyWhenNothing" class="selflink">#</a></p><div class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> version of <code><a href="Agda-Utils-Function.html#v:applyUnless" title="Agda.Utils.Function">applyUnless</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:iterWhile" class="def">iterWhile</a> :: (b -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; (b, a)) -&gt; a -&gt; [(b, a)] <a href="src/Agda.Utils.Function.html#iterWhile" class="link">Source</a> <a href="#v:iterWhile" class="selflink">#</a></p><div class="doc"><p>Repeat a state transition <code class="inline-code">f :: a -&gt; (b, a)</code> with output <code class="inline-code">b</code>
   while condition <code class="inline-code">cond</code> on the output is true.
   Return all intermediate results and the final result
   where <code class="inline-code">cond</code> is <code class="inline-code">False</code>.</p><p>Postconditions (when it terminates):
   <code class="inline-code">fst (last (iterWhile cond f a)) == False</code>.
   <code class="inline-code">all fst (init (interWhile cond f a))</code>.</p></div></div><div class="top"><p class="src"><a id="v:iterate-39-" class="def">iterate'</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#iterate%27" class="link">Source</a> <a href="#v:iterate-39-" class="selflink">#</a></p><div class="doc"><p><code class="inline-code"><code><a href="Agda-Utils-Function.html#v:iterate-39-" title="Agda.Utils.Function">iterate'</a></code> n f x</code> applies <code class="inline-code">f</code> to <code class="inline-code">x</code> <code class="inline-code">n</code> times and returns the
 result.</p><p>The applications are calculated strictly.</p></div></div><div class="top"><p class="src"><a id="v:iterateUntil" class="def">iterateUntil</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#iterateUntil" class="link">Source</a> <a href="#v:iterateUntil" class="selflink">#</a></p><div class="doc"><p>Iteration to fixed-point.</p><p><code class="inline-code">iterateUntil r f a0</code> iterates endofunction <code class="inline-code">f</code>, starting with <code class="inline-code">a0</code>,
   until <code class="inline-code">r</code> relates its result to its input, i.e., <code class="inline-code">f a <code class="inline-code">r</code> a</code>.</p><p>This is the generic pattern behind saturation algorithms.</p><p>If <code class="inline-code">f</code> is monotone with regard to <code class="inline-code">r</code>,
   meaning <code class="inline-code">a <code class="inline-code">r</code> b</code> implies <code class="inline-code">f a <code class="inline-code">r</code> f b</code>,
   and <code class="inline-code">f</code>-chains starting with <code class="inline-code">a0</code> are finite
   then iteration is guaranteed to terminate.</p><p>A typical instance will work on sets, and <code class="inline-code">r</code> could be set inclusion,
   and <code class="inline-code">a0</code> the empty set, and <code class="inline-code">f</code> the step function of a saturation algorithm.</p></div></div><div class="top"><p class="src"><a id="v:iterateUntilM" class="def">iterateUntilM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; m a) -&gt; a -&gt; m a <a href="src/Agda.Utils.Function.html#iterateUntilM" class="link">Source</a> <a href="#v:iterateUntilM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:iterateUntil" title="Agda.Utils.Function">iterateUntil</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:repeatWhile" class="def">repeatWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#repeatWhile" class="link">Source</a> <a href="#v:repeatWhile" class="selflink">#</a></p><div class="doc"><p>Repeat something while a condition on some state is true.
   Return the last state (including the changes of the last
   transition, even if the condition became false then).</p></div></div><div class="top"><p class="src"><a id="v:repeatWhileM" class="def">repeatWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a <a href="src/Agda.Utils.Function.html#repeatWhileM" class="link">Source</a> <a href="#v:repeatWhileM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:repeatWhile" title="Agda.Utils.Function">repeatWhile</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:trampoline" class="def">trampoline</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a) -&gt; a -&gt; b <a href="src/Agda.Utils.Function.html#trampoline" class="link">Source</a> <a href="#v:trampoline" class="selflink">#</a></p><div class="doc"><p>More general trampoline, which allows some final computation
   from iteration state <code class="inline-code">a</code> into result type <code class="inline-code">b</code>.</p></div></div><div class="top"><p class="src"><a id="v:trampolineM" class="def">trampolineM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a)) -&gt; a -&gt; m b <a href="src/Agda.Utils.Function.html#trampolineM" class="link">Source</a> <a href="#v:trampolineM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:trampoline" title="Agda.Utils.Function">trampoline</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:trampolineWhile" class="def">trampolineWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#trampolineWhile" class="link">Source</a> <a href="#v:trampolineWhile" class="selflink">#</a></p><div class="doc"><p>A version of the trampoline function.</p><p>The usual function iterates <code class="inline-code">f :: a -&gt; Maybe a</code> as long
   as <code class="inline-code">Just{}</code> is returned, and returns the last value of <code class="inline-code">a</code>
   upon <code class="inline-code">Nothing</code>.</p><p><code class="inline-code">usualTrampoline f = trampolineWhile $  a -&gt; maybe (False,a) (True,) (f a)</code>.</p><p><code class="inline-code">trampolineWhile</code> is very similar to <code class="inline-code">repeatWhile</code>, only that
   it discards the state on which the condition went <code class="inline-code">False</code>,
   and returns the last state on which the condition was <code class="inline-code">True</code>.</p></div></div><div class="top"><p class="src"><a id="v:trampolineWhileM" class="def">trampolineWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a <a href="src/Agda.Utils.Function.html#trampolineWhileM" class="link">Source</a> <a href="#v:trampolineWhileM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:trampolineWhile" title="Agda.Utils.Function">trampolineWhile</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:on" class="def">on</a> :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c <span class="fixity">infixl 0</span><span class="rightedge"></span> <a href="#v:on" class="selflink">#</a></p><div class="doc"><p><code class="inline-code"><code><a href="Agda-Utils-Function.html#v:on" title="Agda.Utils.Function">on</a></code> b u x y</code> runs the binary function <code class="inline-code">b</code> <em>on</em> the results of applying
 unary function <code class="inline-code">u</code> to two arguments <code class="inline-code">x</code> and <code class="inline-code">y</code>. From the opposite
 perspective, it transforms two inputs and combines the outputs.</p><pre>(op `<code><a href="Agda-Utils-Function.html#v:on" title="Agda.Utils.Function">on</a></code>` f) x y = f x `<code class="inline-code">op</code>` f y</pre><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:on0">Examples</h4><details id="ch:on0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sortBy (compare `on` length) [[0, 1, 2], [0, 1], [], [0]]
</code></strong>[[],[0],[0,1],[0,1,2]]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>((+) `on` length) [1, 2, 3] [-1]
</code></strong>4
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>((,) `on` (*2)) 2 3
</code></strong>(4,6)
</pre></details><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:on1">Algebraic properties</h4><details id="ch:on1"><summary class="hide-when-js-enabled">Expand</summary><ul><li><pre>(*) `on` <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Function.html#v:id" title="Data.Function">id</a></code> = (*) -- (if (*) &#8713; {&#8869;, <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Function.html#v:const" title="Data.Function">const</a></code> &#8869;})</pre></li><li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li><li><pre><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Function.html#v:flip" title="Data.Function">flip</a></code> on f . <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Function.html#v:flip" title="Data.Function">flip</a></code> on g = <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Function.html#v:flip" title="Data.Function">flip</a></code> on (g . f)</pre></li></ul></details></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>