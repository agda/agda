------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.3.4
------------------------------------------------------------------------

Important changes since 2.3.2:

Installation
============

Pragmas and Options
===================

* Pragma NO_TERMINATION_CHECK placed within a mutual block is now
  applied to the whole mutual block (rather than being discarded
  silently).  Adding to the uses 1.-4. outlined in the release notes
  for 2.3.2 we allow:

  3a. Skipping an old-style mutual block: Somewhere within 'mutual'
      block before a type signature or first function clause.

       mutual
         {-# NO_TERMINATION_CHECK #-}
         c : A
         c = d

         d : A
         d = c

Language
========

* Function clauses may now have different arity, e.g.,

    Sum : ‚Ñï ‚Üí Set
    Sum 0       = ‚Ñï
    Sum (suc n) = ‚Ñï ‚Üí Sum n

    sum : (n : ‚Ñï) ‚Üí ‚Ñï ‚Üí Sum n
    sum 0       acc   = acc
    sum (suc n) acc m = sum n (m + acc)

  or,

    T : Bool ‚Üí Set
    T true  = Bool
    T false = Bool ‚Üí Bool

    f : (b : Bool) ‚Üí T b
    f false true  = false
    f false false = true
    f true = true

* Ambiguous names in patterns are now optimistically resolved in favor
  of constructors. [Issue 822] In particular, the following succeeds now:

    module M where

      data D : Set‚ÇÅ where
        [_] : Set ‚Üí D

    postulate [_] : Set ‚Üí Set

    open M

    Foo : _ ‚Üí Set
    Foo [ A ] = A

* Anonymous where-modules are opened public. [Issue 848]

    <clauses>
    f args = rhs
      module _ telescope where
        body
    <more clauses>

  means the following (not proper Agda code, since you cannot put a
  module in-between clauses)

    <clauses>
    module _ {arg-telescope} telescope where
      body

    f args = rhs
    <more clauses>

  Example:

    A : Set1
    A = B module _ where
      B : Set1
      B = Set

    C : Set1
    C = B


Goal and error display
======================

* The error message "Refuse to construct infinite term" has been
  removed, instead one gets unsolved meta variables.  Reason: the
  error was thrown over-eagerly. [Issue 795]

* If an interactive case split fails with message

    Since goal is solved, further case distinction is not supported;
    try `Solve constraints' instead

  then the associated interaction meta is assigned to a solution.
  Press C-c C-= (Show constraints) to view the solution and C-c C-s
  (Solve constraints) to apply it. [Issue 289]

Type checking
=============

* A buggy facility coined "matrix-shaped orders" that supported
  uncurried functions (which take tuples of arguments instead of one
  argument after another) has been removed from the termination
  checker. [Issue 787]

* Definitions which fail the termination checker are not unfolded any
  longer to avoid loops or stack overflows in Agda.  However, the
  termination checker for a mutual block is only invoked after
  type-checking, so there can still be loops if you define a
  non-terminating function.  But termination checking now happens
  befor the other supplementary checks: positivity, polarity,
  injectivity and projection-likeness.
  Note that with the pragma {-# NO_TERMINATION_CHECK #-} you can make
  Agda treat any function as terminating.

* Implicit patterns of record type are now only eta-expanded if there
  is a record constructor. [Issues 473, 635]

    data D : Set where
      d : D

    data P : D ‚Üí Set where
      p : P d

    record Rc : Set where
      constructor c
      field f : D

    works : {r : Rc} ‚Üí P (Rc.f r) ‚Üí Set
    works p = D

  This works since the implicit pattern {r} is eta-expanded to
  {c x} which allows the type of p to reduce to P x and x to be
  unified with d.  The corresponding explicit version is:

    works' : (r : Rc) ‚Üí P (Rc.f r) ‚Üí Set
    works' (c .d) p = D

  However, if the record constructor is removed, the same example will
  fail:

    record R : Set where
      field f : D

    fails : {r : R} ‚Üí P (R.f r) ‚Üí Set
    fails p = D

    -- d != R.f r of type D
    -- when checking that the pattern p has type P (R.f r)

  The error is justified since there is no pattern we could write down
  for r.  It would have to look like

    record { f = .d }

  but anonymous record patterns are not part of the language.

Compiler backends
=================

Tools
=====

Emacs mode
----------

* Key bindings for lots of "mathematical" characters (examples: ùê¥ùë®ùíúùìêùîÑ)
  have been added to the Agda input method.

* Key bindings for "blackboard bold" B (ùîπ) and 0-9 (ùüò-ùü°) have been added
  to the Agda input method (\bb and \b[0-9]).

LaTeX-backend
-------------

* Two new color scheme options were added to agda.sty:

  \usepackage[bw]{agda}, which highlights in black and white;
  \usepackage[conor]{agda}, which highlights using Conor's colors.

  The default (no options passed) is to use the standard colors.

* If agda.sty cannot be found by the latex environment, it is now
  copied into the latex output directory ('latex' by default) instead
  of the working directory. This means that the commands needed to
  produce a PDF now is

    agda --latex -i . <file>.lagda
    cd latex
    pdflatex <file>.tex
